{
  "version": 3,
  "sources": ["../backend/services/docker.ts", "../backend/services/workspaceManager.ts", "../backend/server.ts", "../backend/routes/auth.ts", "../backend/services/oauth.ts", "../backend/services/session.ts", "../backend/middleware/auth.ts", "../backend/services/auditLogger.ts", "../backend/middleware/rateLimit.ts", "../backend/routes/auth_otp.ts", "../backend/routes/workspaces.ts", "../backend/routes/repositories.ts", "../backend/routes/jobs.ts", "../backend/routes/organizations.ts", "../backend/middleware/roles.ts", "../backend/services/audit.ts", "../backend/routes/community.ts", "../backend/routes/profile.ts", "../backend/routes/forge.ts", "../backend/services/terminal.ts", "../backend/services/notification.ts", "../backend/services/chat.ts", "../backend/routes/notifications.ts", "../backend/routes/admin.ts", "../backend/routes/search.ts", "../backend/routes/index.ts", "../backend/middleware/csrf.ts"],
  "sourcesContent": ["import DockerModule from \"dockerode\";\r\nconst Docker = (DockerModule as any).default || DockerModule;\r\nimport path from \"path\";\r\nimport fs from \"fs/promises\";\r\n\r\nimport process from \"process\";\r\n\r\nexport const docker = new Docker(\r\n  process.platform === \"win32\"\r\n    ? { socketPath: \"//./pipe/docker_engine\" }\r\n    : undefined,\r\n);\r\n\r\nexport class DockerService {\r\n  // Create a new container for a workspace\r\n  static async createContainer(\r\n    workspaceId: string,\r\n    image: string = \"gitpod/openvscode-server:latest\",\r\n    port: number = 3000,\r\n  ) {\r\n    const workspacePath = path.resolve(\r\n      process.cwd(),\r\n      \"workspaces\",\r\n      workspaceId,\r\n    );\r\n\r\n    // Ensure workspace dir exists\r\n    try {\r\n      await fs.mkdir(workspacePath, { recursive: true });\r\n    } catch (e) {\r\n      console.error(\"Failed to create workspace dir\", e);\r\n    }\r\n\r\n    const name = `trackcodex-${workspaceId}`;\r\n\r\n    // Remove existing if any\r\n    try {\r\n      const old = docker.getContainer(name);\r\n      await old.remove({ force: true });\r\n    } catch (e) {\r\n      // Ignore if not found\r\n    }\r\n\r\n    // Ensure image exists\r\n    try {\r\n      const imageInspect = await docker.getImage(image).inspect();\r\n    } catch (e) {\r\n      console.log(`Pulling image ${image}... this may take a while.`);\r\n      await new Promise((resolve, reject) => {\r\n        docker.pull(image, (err: any, stream: any) => {\r\n          if (err) return reject(err);\r\n          docker.modem.followProgress(stream, onFinished, onProgress);\r\n          function onFinished(err: any, output: any) {\r\n            if (err) return reject(err);\r\n            resolve(output);\r\n          }\r\n          function onProgress(event: any) {\r\n            // console.log(event);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    const container = await docker.createContainer({\r\n      Image: image,\r\n      name: name,\r\n      Tty: true,\r\n      ExposedPorts: {\r\n        \"3000/tcp\": {},\r\n      },\r\n      HostConfig: {\r\n        // Bind container port 3000 to dynamic host port\r\n        PortBindings: {\r\n          \"3000/tcp\": [{ HostPort: port.toString() }],\r\n        },\r\n        // Mount local workspace folder\r\n        Binds: [\r\n          `${workspacePath}:/home/workspace`,\r\n          // Inject default settings for parity\r\n          `${path.resolve(process.cwd(), \"config\", \"default-settings.json\")}:/home/workspace/.vscode/settings.json`,\r\n          // branding override (Attempt to override)\r\n          `${path.resolve(process.cwd(), \"config\", \"product.json\")}:/home/workspace/product.json`,\r\n        ],\r\n        AutoRemove: true,\r\n      },\r\n      Env: [\r\n        \"CONNECTION_TOKEN=trackcodex-secure-token\", // Secure access in production\r\n        \"OPENVSCODE_SERVER_ROOT=/home/workspace\",\r\n        // Force theme (Note: OpenVSCode uses browser storage for some things, but file overrides help)\r\n        'EXTENSIONS_GALLERY={\"serviceUrl\":\"https://open-vsx.org/vscode/gallery\",\"itemUrl\":\"https://open-vsx.org/vscode/item\"}',\r\n      ],\r\n      // Command to start server without auth for local dev ease, or use token\r\n      // Command to start server without auth for local dev ease, or use token\r\n      // Pre-install critical extensions for Antigravity Parity\r\n      Cmd: [\r\n        \"--port\",\r\n        \"3000\",\r\n        \"--host\",\r\n        \"0.0.0.0\",\r\n        \"--without-connection-token\",\r\n        \"--telemetry-level\",\r\n        \"off\",\r\n        \"--install-extension\",\r\n        \"dbaeumer.vscode-eslint\",\r\n        \"--install-extension\",\r\n        \"esbenp.prettier-vscode\",\r\n        \"--install-extension\",\r\n        \"ms-python.python\",\r\n        \"--install-extension\",\r\n        \"bradlc.vscode-tailwindcss\",\r\n        \"/home/workspace\",\r\n      ],\r\n    });\r\n\r\n    await container.start();\r\n    return { containerId: container.id, name, port };\r\n  }\r\n\r\n  // Execute command\r\n  static async exec(containerId: string, cmd: string[]) {\r\n    const container = docker.getContainer(containerId);\r\n    const exec = await container.exec({\r\n      Cmd: cmd,\r\n      AttachStdout: true,\r\n      AttachStderr: true,\r\n    });\r\n\r\n    const stream = await exec.start({ hijack: true, stdin: false });\r\n\r\n    return new Promise<string>((resolve, reject) => {\r\n      let output = \"\";\r\n      container.modem.demuxStream(\r\n        stream,\r\n        {\r\n          write: (chunk: Buffer) => (output += chunk.toString()),\r\n        },\r\n        {\r\n          write: (chunk: Buffer) => (output += chunk.toString()),\r\n        },\r\n      );\r\n      stream.on(\"end\", () => resolve(output));\r\n    });\r\n  }\r\n\r\n  // Stop\r\n  static async stop(containerId: string) {\r\n    const container = docker.getContainer(containerId);\r\n    await container.stop();\r\n  }\r\n}\r\n", "import { DockerService } from \"./docker\";\r\n\r\n// Simple in-memory storage for active workspace ports\r\n// In production, this should be in Redis or Database\r\nconst activeWorkspaces = new Map<string, number>();\r\nconst START_PORT = 3001;\r\n\r\nexport class WorkspaceManager {\r\n  // Get an available port\r\n  static async allocatePort(): Promise<number> {\r\n    let port = START_PORT;\r\n    while (Array.from(activeWorkspaces.values()).includes(port)) {\r\n      port++;\r\n    }\r\n    return port;\r\n  }\r\n\r\n  // Start a workspace container and return the access URL\r\n  static async startWorkspace(\r\n    workspaceId: string,\r\n  ): Promise<{ url: string; port: number }> {\r\n    // Check if already running\r\n    if (activeWorkspaces.has(workspaceId)) {\r\n      const port = activeWorkspaces.get(workspaceId)!;\r\n      return {\r\n        url: `http://localhost:${port}`,\r\n        port,\r\n      };\r\n    }\r\n\r\n    const port = await this.allocatePort();\r\n\r\n    try {\r\n      await DockerService.createContainer(\r\n        workspaceId,\r\n        \"gitpod/openvscode-server:latest\",\r\n        port,\r\n      );\r\n      activeWorkspaces.set(workspaceId, port);\r\n\r\n      // Wait a brief moment for server to boot? (Optional, usually frontend handles retry)\r\n      return {\r\n        url: `http://localhost:${port}`,\r\n        port,\r\n      };\r\n    } catch (error) {\r\n      console.error(`Failed to start workspace ${workspaceId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  static async stopWorkspace(workspaceId: string) {\r\n    // We'd need the container ID ideally, but assuming naming convention in DockerService\r\n    const containerName = `trackcodex-${workspaceId}`;\r\n    try {\r\n      // This is a bit leaky relying on name, but fine for MVP\r\n      const docker = (await import(\"./docker\")).docker;\r\n      const container = docker.getContainer(containerName);\r\n      await container.stop();\r\n    } catch (e) {\r\n      // Ignore\r\n    }\r\n    activeWorkspaces.delete(workspaceId);\r\n  }\r\n}\r\n", "// Fix: Import process from 'process' to ensure the Node.js process object is correctly typed\r\nimport process from \"process\";\r\nimport { env } from \"./config/env\"; // Strict Env Validation\r\n\r\nimport Fastify from \"fastify\";\r\nimport cors from \"@fastify/cors\";\r\nimport websocket from \"@fastify/websocket\";\r\nimport cookie from \"@fastify/cookie\";\r\nimport helmet from \"@fastify/helmet\";\r\nimport rateLimit from \"@fastify/rate-limit\";\r\n\r\nimport { routes } from \"./routes/index\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport {\r\n  rateLimitKeyGenerator,\r\n  rateLimitErrorHandler,\r\n} from \"./middleware/rateLimit\";\r\nimport { csrfProtection } from \"./middleware/csrf\";\r\n\r\nconst server = Fastify({\r\n  logger: true,\r\n  // Trust proxy for correct IP detection behind load balancers/reverse proxies\r\n  trustProxy: true,\r\n});\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nasync function bootstrap() {\r\n  // 1. Security Headers (Helmet) - First line of defense\r\n  await server.register(helmet, {\r\n    contentSecurityPolicy: {\r\n      directives: {\r\n        defaultSrc: [\"'self'\"],\r\n        scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"'unsafe-eval'\"], // Adjust for React/Vite\r\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\r\n        imgSrc: [\"'self'\", \"data:\", \"https:\"],\r\n        connectSrc: [\r\n          \"'self'\",\r\n          \"http://localhost:3000\",\r\n          \"ws://localhost:4000\",\r\n          \"http://localhost:4000\",\r\n        ],\r\n      },\r\n    },\r\n    global: true,\r\n  });\r\n\r\n  // 2. Cookie Parser - Essential for HttpOnly sessions\r\n  await server.register(cookie, {\r\n    secret:\r\n      process.env.COOKIE_SECRET ||\r\n      \"fallback-secret-change-in-prod-min-32-chars\",\r\n    parseOptions: {},\r\n  });\r\n\r\n  // 3. CORS - Strict configuration with credentials support\r\n  await server.register(cors, {\r\n    origin: [\r\n      process.env.FRONTEND_URL || \"http://localhost:3000\",\r\n      \"http://127.0.0.1:3000\",\r\n    ],\r\n    credentials: true, // Required for HttpOnly cookies\r\n    methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\r\n    allowedHeaders: [\r\n      \"Content-Type\",\r\n      \"Authorization\",\r\n      \"X-CSRF-Token\",\r\n      \"x-user-id\",\r\n    ],\r\n    maxAge: 86400, // cache preflight response for 24 hours\r\n  });\r\n\r\n  // 4. Rate Limiting - DDoS protection\r\n  await server.register(rateLimit, {\r\n    max: 100, // Default limit per IP\r\n    timeWindow: \"15 minutes\",\r\n    keyGenerator: rateLimitKeyGenerator, // Custom key generator using IP + UserID\r\n    errorResponseBuilder: (req, context) => ({\r\n      statusCode: 429,\r\n      error: \"Too Many Requests\",\r\n      message: \"Global rate limit exceeded. Please slow down.\",\r\n      retryAfter: context.ttl,\r\n    }),\r\n  });\r\n\r\n  // 5. CSRF Protection - Global middleware\r\n  // Run on preHandler to ensure cookies are parsed\r\n  server.addHook(\"preHandler\", csrfProtection);\r\n\r\n  // 6. WebSocket Support\r\n  await server.register(websocket);\r\n\r\n  // Root Health Check\r\n  server.get(\"/\", async (request, reply) => {\r\n    // If browser request, redirect to frontend\r\n    if (request.headers[\"accept\"]?.includes(\"text/html\")) {\r\n      return reply.redirect(\"http://localhost:3000\");\r\n    }\r\n    return {\r\n      status: \"online\",\r\n      message: \"TrackCodex Backend Server is running.\",\r\n      api_version: \"v1\",\r\n      security: \"enhanced\",\r\n    };\r\n  });\r\n\r\n  // Register API Routes\r\n  await server.register(routes, { prefix: \"/api/v1\" });\r\n\r\n  // Custom 404 for debugging\r\n  server.setNotFoundHandler((request, reply) => {\r\n    server.log.warn(`404 Encountered: ${request.method} ${request.url}`);\r\n    reply.status(404).send({\r\n      status: \"404_NOT_FOUND\",\r\n      message: `Route ${request.method}:${request.url} is not registered on the TrackCodex Backend.`,\r\n      available_endpoints: [\"/\", \"/api/v1\", \"/api/v1/jobs\"],\r\n    });\r\n  });\r\n\r\n  try {\r\n    // Test DB connection\r\n    await prisma.$connect();\r\n    console.log(\"\u2705 Connected to PostgreSQL database\");\r\n\r\n    const port = process.env.PORT ? parseInt(process.env.PORT) : 4000;\r\n    await server.listen({ port, host: \"0.0.0.0\" });\r\n    console.log(\r\n      `\uD83D\uDE80 TrackCodex Backend operational on port ${port} (Secure Mode)`,\r\n    );\r\n  } catch (err) {\r\n    server.log.error(err);\r\n    await prisma.$disconnect();\r\n  }\r\n}\r\n\r\nbootstrap();\r\n", "import { FastifyInstance } from \"fastify\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport crypto from \"crypto\";\r\nimport {\r\n  exchangeGoogleCode,\r\n  getGoogleUserInfo,\r\n  exchangeGithubCode,\r\n  getGithubUserInfo,\r\n  getGithubUserEmails,\r\n  getPrimaryEmail,\r\n} from \"../services/oauth\";\r\nimport { requireAuth } from \"../middleware/auth\";\r\nimport {\r\n  createSession,\r\n  revokeSession,\r\n  revokeAllUserSessions,\r\n} from \"../services/session\";\r\nimport {\r\n  logLoginAttempt,\r\n  checkSuspiciousActivity,\r\n  logSensitiveOperation,\r\n  logOAuthLink,\r\n} from \"../services/auditLogger\";\r\nimport { rateLimitConfig } from \"../middleware/rateLimit\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function authRoutes(fastify: FastifyInstance) {\r\n  // Register with email/password\r\n  fastify.post(\r\n    \"/auth/register\",\r\n    {\r\n      config: { rateLimit: rateLimitConfig.register },\r\n    },\r\n    async (request, reply) => {\r\n      const { email, password, name, username } = request.body as any;\r\n\r\n      try {\r\n        // Validate input\r\n        if (!email || !password || !name || !username) {\r\n          return reply.code(400).send({ error: \"Missing required fields\" });\r\n        }\r\n\r\n        // Check if user exists\r\n        const existingUser = await prisma.user.findFirst({\r\n          where: { OR: [{ email }, { username }] },\r\n        });\r\n\r\n        if (existingUser) {\r\n          return reply.code(409).send({ error: \"User already exists\" });\r\n        }\r\n\r\n        // Hash password\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n        // Create user\r\n        const user = await prisma.user.create({\r\n          data: {\r\n            email,\r\n            username,\r\n            name,\r\n            password: hashedPassword,\r\n            role: \"user\",\r\n            profileCompleted: true, // Basic registration considered complete\r\n          },\r\n        });\r\n\r\n        // Create Secure Session\r\n        const sessionId = crypto.randomUUID();\r\n        const { csrfToken } = await createSession(\r\n          sessionId,\r\n          {\r\n            userId: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n          },\r\n          {\r\n            ipAddress: request.ip,\r\n            userAgent: request.headers[\"user-agent\"] || \"unknown\",\r\n          },\r\n        );\r\n\r\n        // Set HttpOnly Cookie\r\n        reply.setCookie(\"session_id\", sessionId, {\r\n          path: \"/\",\r\n          httpOnly: true,\r\n          secure: process.env.NODE_ENV === \"production\", // true in prod\r\n          sameSite: \"lax\",\r\n          maxAge: 7 * 24 * 60 * 60, // 7 days in seconds\r\n          signed: false, // Session ID is random enough\r\n        });\r\n\r\n        // Log Success\r\n        await logLoginAttempt(\r\n          email,\r\n          request.ip,\r\n          request.headers[\"user-agent\"] || \"unknown\",\r\n          true,\r\n          user.id,\r\n        );\r\n\r\n        return {\r\n          message: \"Registration successful\",\r\n          csrfToken, // Send valid CSRF token to client\r\n          user: {\r\n            id: user.id,\r\n            email: user.email,\r\n            username: user.username,\r\n            name: user.name,\r\n            avatar: user.avatar,\r\n            role: user.role,\r\n          },\r\n        };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // Login with email/password\r\n  fastify.post(\r\n    \"/auth/login\",\r\n    {\r\n      config: { rateLimit: rateLimitConfig.login },\r\n    },\r\n    async (request, reply) => {\r\n      const { email, password } = request.body as any;\r\n      const ip = request.ip;\r\n      const userAgent = request.headers[\"user-agent\"] || \"unknown\";\r\n\r\n      try {\r\n        // 1. Check Suspicious Activity\r\n        const securityCheck = await checkSuspiciousActivity(email, ip);\r\n        if (securityCheck.shouldLock) {\r\n          await logSensitiveOperation(\r\n            \"system\",\r\n            \"block_login\",\r\n            \"auth\",\r\n            email,\r\n            ip,\r\n            userAgent,\r\n            true,\r\n            { reason: securityCheck.reason },\r\n          );\r\n          return reply.code(403).send({\r\n            error: \"Account Locked\",\r\n            message: \"Too many failed attempts. Account temporarily locked.\",\r\n          });\r\n        }\r\n\r\n        if (!email || !password) {\r\n          return reply.code(400).send({ error: \"Email and password required\" });\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n        // 2. Validate Credentials\r\n        if (!user || !user.password) {\r\n          await logLoginAttempt(\r\n            email,\r\n            ip,\r\n            userAgent,\r\n            false,\r\n            undefined,\r\n            \"invalid_credentials\",\r\n          );\r\n          return reply.code(401).send({ error: \"Invalid credentials\" });\r\n        }\r\n\r\n        const isValidPassword = await bcrypt.compare(password, user.password);\r\n        if (!isValidPassword) {\r\n          await logLoginAttempt(\r\n            email,\r\n            ip,\r\n            userAgent,\r\n            false,\r\n            user.id,\r\n            \"invalid_password\",\r\n          );\r\n          return reply.code(401).send({ error: \"Invalid credentials\" });\r\n        }\r\n\r\n        // 3. Create Secure Session\r\n        const sessionId = crypto.randomUUID();\r\n        const { csrfToken } = await createSession(\r\n          sessionId,\r\n          {\r\n            userId: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n          },\r\n          {\r\n            ipAddress: ip,\r\n            userAgent,\r\n          },\r\n        );\r\n\r\n        // 4. Set HttpOnly Cookie\r\n        reply.setCookie(\"session_id\", sessionId, {\r\n          path: \"/\",\r\n          httpOnly: true,\r\n          secure: process.env.NODE_ENV === \"production\",\r\n          sameSite: \"lax\",\r\n          maxAge: 7 * 24 * 60 * 60, // 7 days\r\n        });\r\n\r\n        // 5. Audit Log\r\n        await logLoginAttempt(email, ip, userAgent, true, user.id);\r\n\r\n        return {\r\n          message: \"Login successful\",\r\n          csrfToken,\r\n          user: {\r\n            id: user.id,\r\n            email: user.email,\r\n            username: user.username,\r\n            name: user.name,\r\n            avatar: user.avatar,\r\n            role: user.role,\r\n          },\r\n        };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // Google OAuth callback\r\n  fastify.post(\r\n    \"/auth/google\",\r\n    {\r\n      config: { rateLimit: rateLimitConfig.oauth },\r\n    },\r\n    async (request, reply) => {\r\n      const { code } = request.body as { code: string };\r\n      const ip = request.ip;\r\n      const userAgent = request.headers[\"user-agent\"] || \"unknown\";\r\n\r\n      try {\r\n        if (!code) {\r\n          return reply.code(400).send({ error: \"Authorization code required\" });\r\n        }\r\n\r\n        // Exchange code for tokens\r\n        const tokenData = await exchangeGoogleCode(code);\r\n\r\n        // Get user info from Google\r\n        const googleUser = await getGoogleUserInfo(tokenData.access_token);\r\n\r\n        // Find or create user logic (simplified for brevity)\r\n        let user = await prisma.user.findFirst({\r\n          where: { email: googleUser.email },\r\n        });\r\n\r\n        if (user) {\r\n          // Link Verification\r\n          const existingLink = await prisma.oAuthAccount.findUnique({\r\n            where: {\r\n              provider_providerAccountId: {\r\n                provider: \"google\",\r\n                providerAccountId: googleUser.id,\r\n              },\r\n            },\r\n          });\r\n\r\n          if (!existingLink) {\r\n            // Create link\r\n            await prisma.oAuthAccount.create({\r\n              data: {\r\n                userId: user.id,\r\n                provider: \"google\",\r\n                providerAccountId: googleUser.id,\r\n                accessToken: tokenData.access_token,\r\n                refreshToken: tokenData.refresh_token,\r\n                tokenType: tokenData.token_type,\r\n                idToken: tokenData.id_token,\r\n              },\r\n            });\r\n            await logOAuthLink(user.id, \"google\", \"link\", ip, userAgent);\r\n          }\r\n        } else {\r\n          // Register new user\r\n          const username =\r\n            googleUser.email.split(\"@\")[0] +\r\n            \"_\" +\r\n            Math.random().toString(36).substring(7);\r\n          user = await prisma.user.create({\r\n            data: {\r\n              email: googleUser.email,\r\n              username,\r\n              name: googleUser.name,\r\n              avatar: googleUser.picture,\r\n              role: \"user\",\r\n              emailVerified: true, // Google verified\r\n              emailVerifiedAt: new Date(),\r\n              oauthAccounts: {\r\n                create: {\r\n                  provider: \"google\",\r\n                  providerAccountId: googleUser.id,\r\n                  accessToken: tokenData.access_token,\r\n                  refreshToken: tokenData.refresh_token,\r\n                  tokenType: tokenData.token_type,\r\n                  idToken: tokenData.id_token,\r\n                },\r\n              },\r\n            },\r\n          });\r\n          await logSensitiveOperation(\r\n            user.id,\r\n            \"register_oauth\",\r\n            \"auth\",\r\n            \"google\",\r\n            ip,\r\n            userAgent,\r\n            true,\r\n          );\r\n        }\r\n\r\n        // Create Session\r\n        const sessionId = crypto.randomUUID();\r\n        const { csrfToken } = await createSession(\r\n          sessionId,\r\n          { userId: user.id, email: user.email, role: user.role },\r\n          { ipAddress: ip, userAgent },\r\n        );\r\n\r\n        reply.setCookie(\"session_id\", sessionId, {\r\n          path: \"/\",\r\n          httpOnly: true,\r\n          secure: process.env.NODE_ENV === \"production\",\r\n          sameSite: \"strict\",\r\n          maxAge: 7 * 24 * 60 * 60,\r\n        });\r\n\r\n        return {\r\n          message: \"OAuth login successful\",\r\n          csrfToken,\r\n          user: {\r\n            id: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n            username: user.username,\r\n            name: user.name,\r\n            avatar: user.avatar,\r\n          },\r\n        };\r\n      } catch (error: any) {\r\n        request.log.error(error);\r\n        return reply\r\n          .code(500)\r\n          .send({ error: error.message || \"OAuth authentication failed\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // GitHub OAuth callback (Email Linking logic included)\r\n  fastify.post(\r\n    \"/auth/github\",\r\n    {\r\n      config: { rateLimit: rateLimitConfig.oauth },\r\n    },\r\n    async (request, reply) => {\r\n      const { code } = request.body as { code: string };\r\n      const ip = request.ip;\r\n      const userAgent = request.headers[\"user-agent\"] || \"unknown\";\r\n\r\n      try {\r\n        if (!code)\r\n          return reply.code(400).send({ error: \"Authorization code required\" });\r\n\r\n        const tokenData = await exchangeGithubCode(code);\r\n        const githubUser = await getGithubUserInfo(tokenData.access_token);\r\n\r\n        let email = githubUser.email;\r\n        if (!email) {\r\n          const emails = await getGithubUserEmails(tokenData.access_token);\r\n          email = getPrimaryEmail(emails);\r\n        }\r\n\r\n        if (!email)\r\n          return reply\r\n            .code(400)\r\n            .send({ error: \"No verified email found in GitHub account\" });\r\n\r\n        // Find existing user by email\r\n        let user = await prisma.user.findUnique({ where: { email } });\r\n\r\n        if (user) {\r\n          // Link account\r\n          const existingLink = await prisma.oAuthAccount.findUnique({\r\n            where: {\r\n              provider_providerAccountId: {\r\n                provider: \"github\",\r\n                providerAccountId: githubUser.id.toString(),\r\n              },\r\n            },\r\n          });\r\n\r\n          if (!existingLink) {\r\n            await prisma.oAuthAccount.create({\r\n              data: {\r\n                userId: user.id,\r\n                provider: \"github\",\r\n                providerAccountId: githubUser.id.toString(),\r\n                accessToken: tokenData.access_token,\r\n                scope: tokenData.scope,\r\n              },\r\n            });\r\n            await logOAuthLink(user.id, \"github\", \"link\", ip, userAgent);\r\n          }\r\n        } else {\r\n          // Register\r\n          const username = githubUser.login;\r\n          user = await prisma.user.create({\r\n            data: {\r\n              email,\r\n              username,\r\n              name: githubUser.name || username,\r\n              avatar: githubUser.avatar_url,\r\n              role: \"user\",\r\n              emailVerified: true,\r\n              emailVerifiedAt: new Date(),\r\n              oauthAccounts: {\r\n                create: {\r\n                  provider: \"github\",\r\n                  providerAccountId: githubUser.id.toString(),\r\n                  accessToken: tokenData.access_token,\r\n                  scope: tokenData.scope,\r\n                },\r\n              },\r\n            },\r\n          });\r\n          await logSensitiveOperation(\r\n            user.id,\r\n            \"register_oauth\",\r\n            \"auth\",\r\n            \"github\",\r\n            ip,\r\n            userAgent,\r\n            true,\r\n          );\r\n        }\r\n\r\n        // Create Session\r\n        const sessionId = crypto.randomUUID();\r\n        const { csrfToken } = await createSession(\r\n          sessionId,\r\n          { userId: user.id, email: user.email, role: user.role },\r\n          { ipAddress: ip, userAgent },\r\n        );\r\n\r\n        reply.setCookie(\"session_id\", sessionId, {\r\n          path: \"/\",\r\n          httpOnly: true,\r\n          secure: process.env.NODE_ENV === \"production\",\r\n          sameSite: \"strict\",\r\n          maxAge: 7 * 24 * 60 * 60,\r\n        });\r\n\r\n        return {\r\n          message: \"OAuth login successful\",\r\n          csrfToken,\r\n          user: {\r\n            id: user.id,\r\n            email: user.email,\r\n            role: user.role,\r\n            username: user.username,\r\n            name: user.name,\r\n            avatar: user.avatar,\r\n          },\r\n        };\r\n      } catch (error: any) {\r\n        request.log.error(error);\r\n        return reply\r\n          .code(500)\r\n          .send({ error: error.message || \"OAuth authentication failed\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // Logout\r\n  fastify.post(\r\n    \"/auth/logout\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const sessionId = request.cookies.session_id;\r\n      if (sessionId) {\r\n        await revokeSession(sessionId);\r\n        reply.clearCookie(\"session_id\", { path: \"/\" });\r\n\r\n        // Log logout\r\n        const user = (request as any).user;\r\n        await logLoginAttempt(\r\n          user.email,\r\n          request.ip,\r\n          request.headers[\"user-agent\"] || \"unknown\",\r\n          true,\r\n          user.userId,\r\n          \"logout\",\r\n        );\r\n      }\r\n      return { message: \"Logged out successfully\" };\r\n    },\r\n  );\r\n\r\n  // Global Logout (Invalidate ALL sessions)\r\n  fastify.post(\r\n    \"/auth/logout-everywhere\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const user = (request as any).user;\r\n\r\n      try {\r\n        // Increment token version to invalidate all past sessions\r\n        await prisma.user.update({\r\n          where: { id: user.userId },\r\n          data: { tokenVersion: { increment: 1 } },\r\n        });\r\n\r\n        // Also revoke physical session records for good measure\r\n        await revokeAllUserSessions(user.userId);\r\n\r\n        reply.clearCookie(\"session_id\", { path: \"/\" });\r\n        return { message: \"Logged out from all devices successfully\" };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // --- Email Verification ---\r\n  fastify.post(\r\n    \"/auth/verify-email/request\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const user = (request as any).user;\r\n      // In a real app, you'd rate limit this aggressively\r\n\r\n      try {\r\n        const token = crypto.randomUUID();\r\n        const expires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours\r\n\r\n        // Store token\r\n        await prisma.verificationToken.create({\r\n          data: {\r\n            identifier: user.email,\r\n            token,\r\n            expires,\r\n          },\r\n        });\r\n\r\n        // Mock Email Sending (Log to console)\r\n        request.log.info(\r\n          `[EMAIL MOCK] To: ${user.email} | Subject: Verify Email | Link: ${process.env.FRONTEND_URL}/verify-email?token=${token}`,\r\n        );\r\n\r\n        return { message: \"Verification email sent\" };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply\r\n          .code(500)\r\n          .send({ error: \"Failed to send verification email\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  fastify.post(\"/auth/verify-email/confirm\", async (request, reply) => {\r\n    const { token } = request.body as { token: string };\r\n\r\n    if (!token) return reply.code(400).send({ error: \"Token required\" });\r\n\r\n    try {\r\n      const verificationToken = await prisma.verificationToken.findUnique({\r\n        where: { token },\r\n      });\r\n\r\n      if (!verificationToken) {\r\n        return reply.code(400).send({ error: \"Invalid token\" });\r\n      }\r\n\r\n      if (verificationToken.expires < new Date()) {\r\n        return reply.code(400).send({ error: \"Token expired\" });\r\n      }\r\n\r\n      // Verify User\r\n      const user = await prisma.user.findUnique({\r\n        where: { email: verificationToken.identifier },\r\n      });\r\n      if (!user) return reply.code(400).send({ error: \"User not found\" });\r\n\r\n      // Update User\r\n      await prisma.user.update({\r\n        where: { id: user.id },\r\n        data: {\r\n          emailVerified: true,\r\n          emailVerifiedAt: new Date(),\r\n        },\r\n      });\r\n\r\n      // Delete token\r\n      await prisma.verificationToken.delete({ where: { token } });\r\n\r\n      return { message: \"Email verified successfully\" };\r\n    } catch (error) {\r\n      request.log.error(error);\r\n      return reply.code(500).send({ error: \"Verification failed\" });\r\n    }\r\n  });\r\n\r\n  // Get Me (Protected)\r\n  fastify.get(\r\n    \"/auth/me\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      // Return session user (attached by middleware)\r\n      return (request as any).user;\r\n    },\r\n  );\r\n\r\n  // --- Profile Completion ---\r\n  fastify.post(\r\n    \"/auth/profile/complete\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const { username, name, bio, role } = request.body as any;\r\n      const user = (request as any).user;\r\n\r\n      try {\r\n        const updatedUser = await prisma.user.update({\r\n          where: { id: user.userId },\r\n          data: {\r\n            username,\r\n            name,\r\n            profileCompleted: true,\r\n            // In a real app, storing bio/role would likely be in a Profile relation\r\n            // For now updating core user if fields exist or ignoring\r\n          },\r\n        });\r\n        return { message: \"Profile updated\", user: updatedUser };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Failed to update profile\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // --- Session Management ---\r\n\r\n  // Get active sessions\r\n  fastify.get(\r\n    \"/auth/sessions\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const user = (request as any).user;\r\n      const currentSessionId = request.cookies.session_id;\r\n\r\n      try {\r\n        const sessions = await prisma.session.findMany({\r\n          where: {\r\n            userId: user.userId,\r\n            revokedAt: null,\r\n            expiresAt: { gte: new Date() },\r\n          },\r\n          orderBy: { lastActivityAt: \"desc\" },\r\n          select: {\r\n            id: true,\r\n            ipAddress: true,\r\n            userAgent: true,\r\n            lastActivityAt: true,\r\n            sessionId: true, // Need this to identify current session\r\n          },\r\n        });\r\n\r\n        // Map to hide internal IDs and flag current session\r\n        return sessions.map((s) => ({\r\n          id: s.sessionId, // Use public session ID\r\n          ipAddress: s.ipAddress,\r\n          userAgent: s.userAgent,\r\n          lastActivityAt: s.lastActivityAt,\r\n          isCurrent: s.sessionId === currentSessionId,\r\n        }));\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // Revoke specific session\r\n  fastify.delete(\r\n    \"/auth/sessions/:sessionId\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const { sessionId } = request.params as { sessionId: string };\r\n      const user = (request as any).user;\r\n\r\n      try {\r\n        // Verify ownership\r\n        const session = await prisma.session.findUnique({\r\n          where: { sessionId },\r\n        });\r\n\r\n        if (!session || session.userId !== user.userId) {\r\n          return reply.code(404).send({ error: \"Session not found\" });\r\n        }\r\n\r\n        await revokeSession(sessionId);\r\n        return { message: \"Session revoked\" };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // Revoke all other sessions\r\n  fastify.delete(\r\n    \"/auth/sessions\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const user = (request as any).user;\r\n      const currentSessionId = request.cookies.session_id;\r\n\r\n      try {\r\n        await prisma.session.updateMany({\r\n          where: {\r\n            userId: user.userId,\r\n            sessionId: { not: currentSessionId }, // Keep current\r\n            revokedAt: null,\r\n          },\r\n          data: { revokedAt: new Date() },\r\n        });\r\n        return { message: \"All other sessions revoked\" };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // --- Audit Logs ---\r\n  fastify.get(\r\n    \"/auth/audit-logs\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const user = (request as any).user;\r\n      try {\r\n        // Fetch login attempts (since that's what the UI expects for now)\r\n        // Ideally we'd merge ActivityLog and LoginAttempt or use just ActivityLog\r\n        const logs = await prisma.loginAttempt.findMany({\r\n          where: {\r\n            userId: user.userId,\r\n          },\r\n          orderBy: { createdAt: \"desc\" },\r\n          take: 20,\r\n        });\r\n\r\n        return logs.map((l) => ({\r\n          id: l.id,\r\n          action: l.success ? \"login_success\" : \"login_failed\",\r\n          ipAddress: l.ipAddress,\r\n          userAgent: l.userAgent,\r\n          success: l.success,\r\n          createdAt: l.createdAt,\r\n          details: { reason: l.failureReason },\r\n        }));\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // --- Linked Accounts ---\r\n  fastify.get(\r\n    \"/auth/connections\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const user = (request as any).user;\r\n      try {\r\n        const accounts = await prisma.oAuthAccount.findMany({\r\n          where: { userId: user.userId },\r\n          select: { provider: true },\r\n        });\r\n\r\n        return {\r\n          google: accounts.some((a) => a.provider === \"google\"),\r\n          github: accounts.some((a) => a.provider === \"github\"),\r\n        };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  fastify.delete(\r\n    \"/auth/connections/:provider\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const { provider } = request.params as { provider: string };\r\n      const user = (request as any).user;\r\n\r\n      try {\r\n        // Prevent unlinking if it's the only method (simplified check)\r\n        // Ideally check if password exists or other providers exist\r\n        const connectionCount = await prisma.oAuthAccount.count({\r\n          where: { userId: user.userId },\r\n        });\r\n\r\n        const dbUser = await prisma.user.findUnique({\r\n          where: { id: user.userId },\r\n          select: { password: true },\r\n        });\r\n\r\n        if (connectionCount <= 1 && !dbUser?.password) {\r\n          return reply\r\n            .code(400)\r\n            .send({ error: \"Cannot unlink last sign-in method\" });\r\n        }\r\n\r\n        await prisma.oAuthAccount.deleteMany({\r\n          where: {\r\n            userId: user.userId,\r\n            provider,\r\n          },\r\n        });\r\n\r\n        return { message: \"Account unlinked\" };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n\r\n  // --- Account Deletion ---\r\n  fastify.delete(\r\n    \"/auth/account\",\r\n    { preHandler: requireAuth },\r\n    async (request, reply) => {\r\n      const { password, confirmation } = request.body as any;\r\n      const user = (request as any).user;\r\n\r\n      if (confirmation !== \"DELETE\") {\r\n        return reply.code(400).send({ error: \"Invalid confirmation code\" });\r\n      }\r\n\r\n      try {\r\n        const dbUser = await prisma.user.findUnique({\r\n          where: { id: user.userId },\r\n        });\r\n\r\n        if (!dbUser) {\r\n          return reply.code(404).send({ error: \"User not found\" });\r\n        }\r\n\r\n        // Verify password if user has one\r\n        if (dbUser.password) {\r\n          if (!password) {\r\n            return reply.code(400).send({ error: \"Password required\" });\r\n          }\r\n          const isValid = await bcrypt.compare(password, dbUser.password);\r\n          if (!isValid) {\r\n            return reply.code(401).send({ error: \"Invalid password\" });\r\n          }\r\n        }\r\n\r\n        // Soft delete user\r\n        await prisma.user.update({\r\n          where: { id: user.userId },\r\n          data: {\r\n            deletedAt: new Date(),\r\n            deleteScheduledFor: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n            email: `deleted_${Date.now()}_${dbUser.email}`, // Free up email immediately\r\n            username: `deleted_${Date.now()}_${dbUser.username}`,\r\n          },\r\n        });\r\n\r\n        // Revoke all sessions\r\n        await revokeSession(request.cookies.session_id); // Current\r\n        await prisma.session.updateMany({\r\n          where: { userId: user.userId },\r\n          data: { revokedAt: new Date() },\r\n        });\r\n\r\n        // Log it\r\n        await logSensitiveOperation(\r\n          user.userId,\r\n          \"delete_account\",\r\n          \"user\",\r\n          user.userId,\r\n          request.ip,\r\n          request.headers[\"user-agent\"] || \"unknown\",\r\n          true,\r\n        );\r\n\r\n        reply.clearCookie(\"session_id\", { path: \"/\" });\r\n        return { message: \"Account deleted successfully\" };\r\n      } catch (error) {\r\n        request.log.error(error);\r\n        return reply.code(500).send({ error: \"Internal Server Error\" });\r\n      }\r\n    },\r\n  );\r\n}\r\n", "/**\r\n * OAuth Service for Google and GitHub authentication\r\n * Handles OAuth2 flows, token exchange, and user profile fetching\r\n */\r\n\r\nconst GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID || '';\r\nconst GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET || '';\r\nconst GOOGLE_REDIRECT_URI = process.env.GOOGLE_REDIRECT_URI || 'http://localhost:3000/auth/callback/google';\r\n\r\nconst GITHUB_CLIENT_ID = process.env.GITHUB_CLIENT_ID || '';\r\nconst GITHUB_CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET || '';\r\nconst GITHUB_REDIRECT_URI = process.env.GITHUB_REDIRECT_URI || 'http://localhost:3000/auth/callback/github';\r\n\r\nexport interface GoogleUserInfo {\r\n    id: string;\r\n    email: string;\r\n    verified_email: boolean;\r\n    name: string;\r\n    given_name: string;\r\n    family_name: string;\r\n    picture: string;\r\n}\r\n\r\nexport interface GitHubUserInfo {\r\n    id: number;\r\n    login: string;\r\n    email: string | null;\r\n    name: string | null;\r\n    avatar_url: string;\r\n}\r\n\r\nexport interface GitHubEmail {\r\n    email: string;\r\n    primary: boolean;\r\n    verified: boolean;\r\n    visibility: string | null;\r\n}\r\n\r\n/**\r\n * Generate Google OAuth authorization URL\r\n */\r\nexport function getGoogleAuthUrl(state?: string): string {\r\n    const params = new URLSearchParams({\r\n        client_id: GOOGLE_CLIENT_ID,\r\n        redirect_uri: GOOGLE_REDIRECT_URI,\r\n        response_type: 'code',\r\n        scope: 'openid email profile',\r\n        access_type: 'offline',\r\n        prompt: 'consent',\r\n        ...(state && { state })\r\n    });\r\n\r\n    return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;\r\n}\r\n\r\n/**\r\n * Exchange Google authorization code for access token\r\n */\r\nexport async function exchangeGoogleCode(code: string): Promise<{\r\n    access_token: string;\r\n    refresh_token?: string;\r\n    expires_in: number;\r\n    token_type: string;\r\n    id_token?: string;\r\n}> {\r\n    const response = await fetch('https://oauth2.googleapis.com/token', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n        body: new URLSearchParams({\r\n            code,\r\n            client_id: GOOGLE_CLIENT_ID,\r\n            client_secret: GOOGLE_CLIENT_SECRET,\r\n            redirect_uri: GOOGLE_REDIRECT_URI,\r\n            grant_type: 'authorization_code'\r\n        })\r\n    });\r\n\r\n    if (!response.ok) {\r\n        const error = await response.text();\r\n        throw new Error(`Google token exchange failed: ${error}`);\r\n    }\r\n\r\n    return response.json();\r\n}\r\n\r\n/**\r\n * Fetch Google user profile information\r\n */\r\nexport async function getGoogleUserInfo(accessToken: string): Promise<GoogleUserInfo> {\r\n    const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\r\n        headers: { Authorization: `Bearer ${accessToken}` }\r\n    });\r\n\r\n    if (!response.ok) {\r\n        throw new Error('Failed to fetch Google user info');\r\n    }\r\n\r\n    return response.json();\r\n}\r\n\r\n/**\r\n * Generate GitHub OAuth authorization URL\r\n */\r\nexport function getGithubAuthUrl(state?: string): string {\r\n    const params = new URLSearchParams({\r\n        client_id: GITHUB_CLIENT_ID,\r\n        redirect_uri: GITHUB_REDIRECT_URI,\r\n        scope: 'read:user user:email',\r\n        ...(state && { state })\r\n    });\r\n\r\n    return `https://github.com/login/oauth/authorize?${params.toString()}`;\r\n}\r\n\r\n/**\r\n * Exchange GitHub authorization code for access token\r\n */\r\nexport async function exchangeGithubCode(code: string): Promise<{\r\n    access_token: string;\r\n    token_type: string;\r\n    scope: string;\r\n}> {\r\n    const response = await fetch('https://github.com/login/oauth/access_token', {\r\n        method: 'POST',\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            Accept: 'application/json'\r\n        },\r\n        body: JSON.stringify({\r\n            client_id: GITHUB_CLIENT_ID,\r\n            client_secret: GITHUB_CLIENT_SECRET,\r\n            code,\r\n            redirect_uri: GITHUB_REDIRECT_URI\r\n        })\r\n    });\r\n\r\n    if (!response.ok) {\r\n        const error = await response.text();\r\n        throw new Error(`GitHub token exchange failed: ${error}`);\r\n    }\r\n\r\n    return response.json();\r\n}\r\n\r\n/**\r\n * Fetch GitHub user profile information\r\n */\r\nexport async function getGithubUserInfo(accessToken: string): Promise<GitHubUserInfo> {\r\n    const response = await fetch('https://api.github.com/user', {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n            Accept: 'application/vnd.github.v3+json'\r\n        }\r\n    });\r\n\r\n    if (!response.ok) {\r\n        throw new Error('Failed to fetch GitHub user info');\r\n    }\r\n\r\n    return response.json();\r\n}\r\n\r\n/**\r\n * Fetch GitHub user emails (needed because email might not be public)\r\n */\r\nexport async function getGithubUserEmails(accessToken: string): Promise<GitHubEmail[]> {\r\n    const response = await fetch('https://api.github.com/user/emails', {\r\n        headers: {\r\n            Authorization: `Bearer ${accessToken}`,\r\n            Accept: 'application/vnd.github.v3+json'\r\n        }\r\n    });\r\n\r\n    if (!response.ok) {\r\n        throw new Error('Failed to fetch GitHub user emails');\r\n    }\r\n\r\n    return response.json();\r\n}\r\n\r\n/**\r\n * Get primary verified email from GitHub\r\n */\r\nexport function getPrimaryEmail(emails: GitHubEmail[]): string | null {\r\n    const primaryEmail = emails.find(e => e.primary && e.verified);\r\n    if (primaryEmail) return primaryEmail.email;\r\n\r\n    const verifiedEmail = emails.find(e => e.verified);\r\n    if (verifiedEmail) return verifiedEmail.email;\r\n\r\n    return emails[0]?.email || null;\r\n}\r\n", "/**\r\n * Session Management Service with Redis Store\r\n * Provides secure HttpOnly cookie-based sessions with Redis backing\r\n */\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\nimport crypto from 'crypto';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport interface SessionData {\r\n    userId: string;\r\n    email: string;\r\n    role: string;\r\n    tokenVersion?: number; // Added for verification\r\n    organizationId?: string;\r\n    workspaceId?: string;\r\n}\r\n\r\nexport interface SessionMetadata {\r\n    ipAddress: string;\r\n    userAgent: string;\r\n}\r\n\r\n/**\r\n * Create a new session\r\n */\r\nexport async function createSession(\r\n    sessionId: string,\r\n    data: SessionData,\r\n    metadata: SessionMetadata,\r\n    expiresInMs: number = 7 * 24 * 60 * 60 * 1000 // 7 days\r\n): Promise<{ sessionId: string; csrfToken: string }> {\r\n    const expiresAt = new Date(Date.now() + expiresInMs);\r\n    const csrfToken = crypto.randomBytes(32).toString('hex');\r\n\r\n    // Ensure we have current token version if not passed (fetch user)\r\n    let tokenVersion = data.tokenVersion;\r\n    if (tokenVersion === undefined) {\r\n        const user = await prisma.user.findUnique({ where: { id: data.userId }, select: { tokenVersion: true } });\r\n        tokenVersion = user?.tokenVersion || 1;\r\n    }\r\n\r\n    await prisma.session.create({\r\n        data: {\r\n            sessionId,\r\n            userId: data.userId,\r\n            organizationId: data.organizationId || null,\r\n            workspaceId: data.workspaceId || null,\r\n            ipAddress: metadata.ipAddress,\r\n            userAgent: metadata.userAgent,\r\n            csrfToken,\r\n            tokenVersion,\r\n            expiresAt,\r\n            lastActivityAt: new Date()\r\n        }\r\n    });\r\n\r\n    return { sessionId, csrfToken };\r\n}\r\n\r\n/**\r\n * Get session data\r\n */\r\nexport async function getSession(sessionId: string): Promise<(SessionData & { csrfToken: string }) | null> {\r\n    const session = await prisma.session.findUnique({\r\n        where: { sessionId },\r\n        include: { user: true }\r\n    });\r\n\r\n    if (!session) return null;\r\n\r\n    // Check version match (Global Logout)\r\n    if (session.tokenVersion !== session.user.tokenVersion) {\r\n        await revokeSession(sessionId);\r\n        return null;\r\n    }\r\n\r\n    // Check if expired\r\n    if (session.expiresAt < new Date()) {\r\n        await revokeSession(sessionId);\r\n        return null;\r\n    }\r\n\r\n    // Check if revoked\r\n    if (session.revokedAt) {\r\n        return null;\r\n    }\r\n\r\n    // Update last activity\r\n    await prisma.session.update({\r\n        where: { sessionId },\r\n        data: { lastActivityAt: new Date() }\r\n    });\r\n\r\n    return {\r\n        userId: session.userId,\r\n        email: session.user.email,\r\n        role: session.user.role,\r\n        tokenVersion: session.tokenVersion,\r\n        organizationId: session.organizationId || undefined,\r\n        workspaceId: session.workspaceId || undefined,\r\n        csrfToken: session.csrfToken\r\n    };\r\n}\r\n\r\n/**\r\n * Revoke a session (logout)\r\n */\r\nexport async function revokeSession(sessionId: string): Promise<void> {\r\n    await prisma.session.update({\r\n        where: { sessionId },\r\n        data: { revokedAt: new Date() }\r\n    }).catch(() => {\r\n        // Session might not exist, that's okay\r\n    });\r\n}\r\n\r\n/**\r\n * Revoke all sessions for a user\r\n */\r\nexport async function revokeAllUserSessions(userId: string): Promise<void> {\r\n    await prisma.session.updateMany({\r\n        where: {\r\n            userId,\r\n            revokedAt: null\r\n        },\r\n        data: { revokedAt: new Date() }\r\n    });\r\n}\r\n\r\n/**\r\n * Clean up expired sessions (run via cron)\r\n */\r\nexport async function cleanupExpiredSessions(): Promise<number> {\r\n    const result = await prisma.session.deleteMany({\r\n        where: {\r\n            expiresAt: {\r\n                lt: new Date()\r\n            }\r\n        }\r\n    });\r\n\r\n    return result.count;\r\n}\r\n\r\n/**\r\n * Get all active sessions for a user\r\n */\r\nexport async function getUserSessions(userId: string): Promise<Array<{\r\n    id: string;\r\n    ipAddress: string;\r\n    userAgent: string;\r\n    createdAt: Date;\r\n    lastActivityAt: Date;\r\n}>> {\r\n    const sessions = await prisma.session.findMany({\r\n        where: {\r\n            userId,\r\n            revokedAt: null,\r\n            expiresAt: {\r\n                gte: new Date()\r\n            }\r\n        },\r\n        select: {\r\n            id: true,\r\n            ipAddress: true,\r\n            userAgent: true,\r\n            createdAt: true,\r\n            lastActivityAt: true\r\n        },\r\n        orderBy: { lastActivityAt: 'desc' }\r\n    });\r\n\r\n    return sessions;\r\n}\r\n\r\n/**\r\n * Validate CSRF token\r\n */\r\nexport async function validateCsrfToken(sessionId: string, token: string): Promise<boolean> {\r\n    const session = await prisma.session.findUnique({\r\n        where: { sessionId },\r\n        select: { csrfToken: true }\r\n    });\r\n\r\n    return session?.csrfToken === token;\r\n}\r\n", "import { FastifyRequest, FastifyReply } from 'fastify';\r\nimport { getSession } from '../services/session';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n/**\r\n * Authentication middleware - reads session from HttpOnly cookie\r\n * Verifies session and attaches user info to request\r\n */\r\nexport async function requireAuth(request: FastifyRequest, reply: FastifyReply) {\r\n    try {\r\n        // Get session ID from HttpOnly cookie\r\n        const sessionId = request.cookies?.session_id;\r\n\r\n        if (!sessionId) {\r\n            return reply.code(401).send({\r\n                error: 'Unauthorized',\r\n                message: 'No session cookie found'\r\n            });\r\n        }\r\n\r\n        // Get and validate session\r\n        const sessionData = await getSession(sessionId);\r\n\r\n        if (!sessionData) {\r\n            // Clear invalid cookie\r\n            reply.clearCookie('session_id');\r\n            return reply.code(401).send({\r\n                error: 'Unauthorized',\r\n                message: 'Session expired or invalid'\r\n            });\r\n        }\r\n\r\n        // Attach user info to request\r\n        (request as any).user = {\r\n            userId: sessionData.userId,\r\n            email: sessionData.email,\r\n            role: sessionData.role,\r\n            organizationId: sessionData.organizationId,\r\n            workspaceId: sessionData.workspaceId\r\n        };\r\n\r\n        // Attach CSRF token for response\r\n        (request as any).csrfToken = sessionData.csrfToken;\r\n\r\n    } catch (error: any) {\r\n        return reply.code(401).send({\r\n            error: 'Unauthorized',\r\n            message: error.message || 'Authentication failed'\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Optional authentication middleware\r\n * Attaches user if session exists, but doesn't reject if missing\r\n */\r\nexport async function optionalAuth(request: FastifyRequest, reply: FastifyReply) {\r\n    try {\r\n        const sessionId = request.cookies?.session_id;\r\n\r\n        if (sessionId) {\r\n            const sessionData = await getSession(sessionId);\r\n\r\n            if (sessionData) {\r\n                (request as any).user = {\r\n                    userId: sessionData.userId,\r\n                    email: sessionData.email,\r\n                    role: sessionData.role,\r\n                    organizationId: sessionData.organizationId,\r\n                    workspaceId: sessionData.workspaceId\r\n                };\r\n                (request as any).csrfToken = sessionData.csrfToken;\r\n            }\r\n        }\r\n    } catch (error) {\r\n        // Silently fail for optional auth\r\n    }\r\n}\r\n\r\n/**\r\n * Role-based authorization middleware\r\n * Requires authentication and checks user role\r\n */\r\nexport function requireRole(...allowedRoles: string[]) {\r\n    return async (request: FastifyRequest, reply: FastifyReply) => {\r\n        // First ensure user is authenticated\r\n        await requireAuth(request, reply);\r\n\r\n        const user = (request as any).user;\r\n        if (!user) {\r\n            return reply.code(401).send({\r\n                error: 'Unauthorized',\r\n                message: 'Authentication required'\r\n            });\r\n        }\r\n\r\n        // Check if user has required role\r\n        if (!allowedRoles.includes(user.role)) {\r\n            return reply.code(403).send({\r\n                error: 'Forbidden',\r\n                message: `Insufficient permissions. Required role: ${allowedRoles.join(' or ')}`\r\n            });\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Permission-based authorization middleware\r\n * Checks fine-grained permissions on specific resources\r\n */\r\nexport function requirePermission(resource: string, action: string, getResourceId?: (request: FastifyRequest) => string) {\r\n    return async (request: FastifyRequest, reply: FastifyReply) => {\r\n        // First ensure user is authenticated\r\n        await requireAuth(request, reply);\r\n\r\n        const user = (request as any).user;\r\n        if (!user) {\r\n            return reply.code(401).send({\r\n                error: 'Unauthorized',\r\n                message: 'Authentication required'\r\n            });\r\n        }\r\n\r\n        // Super admins bypass permission checks\r\n        if (user.role === 'super_admin') {\r\n            return;\r\n        }\r\n\r\n        // Get resource ID if function provided\r\n        const resourceId = getResourceId ? getResourceId(request) : null;\r\n\r\n        // Check permission\r\n        const hasPermission = await prisma.permission.findFirst({\r\n            where: {\r\n                userId: user.userId,\r\n                resource,\r\n                action,\r\n                ...(resourceId ? { resourceId } : {}),\r\n                OR: [\r\n                    { expiresAt: null },\r\n                    { expiresAt: { gte: new Date() } }\r\n                ]\r\n            }\r\n        });\r\n\r\n        if (!hasPermission) {\r\n            return reply.code(403).send({\r\n                error: 'Forbidden',\r\n                message: `You don't have permission to ${action} this ${resource}`\r\n            });\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Ownership check middleware\r\n * Verifies user owns the resource they're trying to access\r\n */\r\nexport function requireOwnership(resourceType: string, getResourceId: (request: FastifyRequest) => string) {\r\n    return async (request: FastifyRequest, reply: FastifyReply) => {\r\n        // First ensure user is authenticated\r\n        await requireAuth(request, reply);\r\n\r\n        const user = (request as any).user;\r\n        if (!user) {\r\n            return reply.code(401).send({\r\n                error: 'Unauthorized',\r\n                message: 'Authentication required'\r\n            });\r\n        }\r\n\r\n        // Super admins bypass ownership checks\r\n        if (user.role === 'super_admin') {\r\n            return;\r\n        }\r\n\r\n        const resourceId = getResourceId(request);\r\n\r\n        // Check ownership based on resource type\r\n        let isOwner = false;\r\n\r\n        switch (resourceType) {\r\n            case 'workspace': {\r\n                const workspace = await prisma.workspace.findUnique({\r\n                    where: { id: resourceId },\r\n                    select: { ownerId: true }\r\n                });\r\n                isOwner = workspace?.ownerId === user.userId;\r\n                break;\r\n            }\r\n\r\n            case 'job': {\r\n                const job = await prisma.job.findUnique({\r\n                    where: { id: resourceId },\r\n                    select: { creatorId: true }\r\n                });\r\n                isOwner = job?.creatorId === user.userId;\r\n                break;\r\n            }\r\n\r\n            // Add more resource types as needed\r\n\r\n            default:\r\n                return reply.code(400).send({\r\n                    error: 'Invalid Resource Type',\r\n                    message: `Unknown resource type: ${resourceType}`\r\n                });\r\n        }\r\n\r\n        if (!isOwner) {\r\n            return reply.code(403).send({\r\n                error: 'Forbidden',\r\n                message: 'You do not own this resource'\r\n            });\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Require email verification\r\n */\r\nexport async function requireVerifiedEmail(request: FastifyRequest, reply: FastifyReply) {\r\n    await requireAuth(request, reply);\r\n\r\n    const user = (request as any).user;\r\n    if (!user) return;\r\n\r\n    const dbUser = await prisma.user.findUnique({\r\n        where: { id: user.userId },\r\n        select: { emailVerified: true }\r\n    });\r\n\r\n    if (!dbUser?.emailVerified) {\r\n        return reply.code(403).send({\r\n            error: 'Email Not Verified',\r\n            message: 'Please verify your email address to access this resource'\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Require completed profile\r\n */\r\nexport async function requireCompleteProfile(request: FastifyRequest, reply: FastifyReply) {\r\n    await requireAuth(request, reply);\r\n\r\n    const user = (request as any).user;\r\n    if (!user) return;\r\n\r\n    const dbUser = await prisma.user.findUnique({\r\n        where: { id: user.userId },\r\n        select: { profileCompleted: true }\r\n    });\r\n\r\n    if (!dbUser?.profileCompleted) {\r\n        return reply.code(403).send({\r\n            error: 'Profile Incomplete',\r\n            message: 'Please complete your profile to access this resource',\r\n            redirectTo: '/onboarding/profile'\r\n        });\r\n    }\r\n}\r\n", "/**\r\n * Audit Logging Service\r\n * Logs all security-critical events for monitoring and compliance\r\n */\r\n\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport interface AuditEventData {\r\n    userId?: string;\r\n    action: string;\r\n    resource: string;\r\n    resourceId?: string;\r\n    ipAddress: string;\r\n    userAgent: string;\r\n    success: boolean;\r\n    metadata?: Record<string, any>;\r\n    failureReason?: string;\r\n}\r\n\r\n/**\r\n * Log an audit event\r\n */\r\nexport async function logAuditEvent(event: AuditEventData): Promise<void> {\r\n    try {\r\n        await prisma.activityLog.create({\r\n            data: {\r\n                userId: event.userId || null,\r\n                action: event.action,\r\n                details: {\r\n                    resource: event.resource,\r\n                    resourceId: event.resourceId,\r\n                    ipAddress: event.ipAddress,\r\n                    userAgent: event.userAgent,\r\n                    success: event.success,\r\n                    failureReason: event.failureReason,\r\n                    ...event.metadata\r\n                }\r\n            }\r\n        });\r\n    } catch (error) {\r\n        // Don't let audit logging failures break the app\r\n        console.error('Failed to log audit event:', error);\r\n    }\r\n}\r\n\r\n/**\r\n * Log login attempt\r\n */\r\nexport async function logLoginAttempt(\r\n    email: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    success: boolean,\r\n    userId?: string,\r\n    failureReason?: string\r\n): Promise<void> {\r\n    try {\r\n        await prisma.loginAttempt.create({\r\n            data: {\r\n                userId,\r\n                email,\r\n                ipAddress,\r\n                userAgent,\r\n                success,\r\n                failureReason\r\n            }\r\n        });\r\n\r\n        // Also log as audit event\r\n        await logAuditEvent({\r\n            userId,\r\n            action: success ? 'login_success' : 'login_failure',\r\n            resource: 'auth',\r\n            ipAddress,\r\n            userAgent,\r\n            success,\r\n            failureReason,\r\n            metadata: { email }\r\n        });\r\n    } catch (error) {\r\n        console.error('Failed to log login attempt:', error);\r\n    }\r\n}\r\n\r\n/**\r\n * Check for suspicious login activity\r\n * Returns true if account should be locked\r\n */\r\nexport async function checkSuspiciousActivity(email: string, ipAddress: string): Promise<{\r\n    shouldLock: boolean;\r\n    reason?: string;\r\n    failedAttempts?: number;\r\n}> {\r\n    // Check failed attempts in last 15 minutes\r\n    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);\r\n\r\n    const recentFailures = await prisma.loginAttempt.count({\r\n        where: {\r\n            email,\r\n            success: false,\r\n            createdAt: {\r\n                gte: fifteenMinutesAgo\r\n            }\r\n        }\r\n    });\r\n\r\n    // Lock after 5 failed attempts\r\n    if (recentFailures >= 5) {\r\n        return {\r\n            shouldLock: true,\r\n            reason: 'Too many failed login attempts',\r\n            failedAttempts: recentFailures\r\n        };\r\n    }\r\n\r\n    // Check for rapid attempts from different IPs\r\n    const recentAttempts = await prisma.loginAttempt.findMany({\r\n        where: {\r\n            email,\r\n            createdAt: {\r\n                gte: new Date(Date.now() - 5 * 60 * 1000) // 5 minutes\r\n            }\r\n        },\r\n        select: { ipAddress: true },\r\n        distinct: ['ipAddress']\r\n    });\r\n\r\n    if (recentAttempts.length >= 3) {\r\n        return {\r\n            shouldLock: true,\r\n            reason: 'Multiple login attempts from different locations'\r\n        };\r\n    }\r\n\r\n    return { shouldLock: false };\r\n}\r\n\r\n/**\r\n * Log OAuth account linking\r\n */\r\nexport async function logOAuthLink(\r\n    userId: string,\r\n    provider: string,\r\n    action: 'link' | 'unlink',\r\n    ipAddress: string,\r\n    userAgent: string\r\n): Promise<void> {\r\n    await logAuditEvent({\r\n        userId,\r\n        action: `oauth_${action}`,\r\n        resource: 'oauth_account',\r\n        resourceId: provider,\r\n        ipAddress,\r\n        userAgent,\r\n        success: true,\r\n        metadata: { provider }\r\n    });\r\n}\r\n\r\n/**\r\n * Log account deletion\r\n */\r\nexport async function logAccountDeletion(\r\n    userId: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    scheduled: boolean\r\n): Promise<void> {\r\n    await logAuditEvent({\r\n        userId,\r\n        action: scheduled ? 'account_deletion_scheduled' : 'account_deleted',\r\n        resource: 'user',\r\n        resourceId: userId,\r\n        ipAddress,\r\n        userAgent,\r\n        success: true\r\n    });\r\n}\r\n\r\n/**\r\n * Log sensitive operations\r\n */\r\nexport async function logSensitiveOperation(\r\n    userId: string,\r\n    operation: string,\r\n    resource: string,\r\n    resourceId: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    success: boolean,\r\n    metadata?: Record<string, any>\r\n): Promise<void> {\r\n    await logAuditEvent({\r\n        userId,\r\n        action: operation,\r\n        resource,\r\n        resourceId,\r\n        ipAddress,\r\n        userAgent,\r\n        success,\r\n        metadata\r\n    });\r\n}\r\n", "/**\r\n * Rate Limiting Configuration\r\n * Defines rate limits for different authentication endpoints\r\n */\r\n\r\nimport { FastifyRequest, FastifyReply } from 'fastify';\r\n\r\n// Rate limit configurations\r\nexport const rateLimitConfig = {\r\n    // Login attempts: 5 per 15 minutes\r\n    login: {\r\n        max: 5,\r\n        timeWindow: '15 minutes',\r\n        errorResponseBuilder: () => ({\r\n            error: 'Too Many Requests',\r\n            message: 'Too many login attempts. Please try again in 15 minutes.',\r\n            retryAfter: 900 // 15 minutes in seconds\r\n        })\r\n    },\r\n\r\n    // Registration: 3 per hour\r\n    register: {\r\n        max: 3,\r\n        timeWindow: '1 hour',\r\n        errorResponseBuilder: () => ({\r\n            error: 'Too Many Requests',\r\n            message: 'Too many registration attempts. Please try again later.',\r\n            retryAfter: 3600\r\n        })\r\n    },\r\n\r\n    // OAuth: 10 per hour\r\n    oauth: {\r\n        max: 10,\r\n        timeWindow: '1 hour',\r\n        errorResponseBuilder: () => ({\r\n            error: 'Too Many Requests',\r\n            message: 'Too many OAuth attempts. Please try again later.',\r\n            retryAfter: 3600\r\n        })\r\n    },\r\n\r\n    // Password reset: 3 per hour per email\r\n    passwordReset: {\r\n        max: 3,\r\n        timeWindow: '1 hour',\r\n        errorResponseBuilder: () => ({\r\n            error: 'Too Many Requests',\r\n            message: 'Too many password reset requests. Please check your email.',\r\n            retryAfter: 3600\r\n        })\r\n    },\r\n\r\n    // OTP sending: 5 per hour\r\n    otpSend: {\r\n        max: 5,\r\n        timeWindow: '1 hour',\r\n        errorResponseBuilder: () => ({\r\n            error: 'Too Many Requests',\r\n            message: 'Too many OTP requests. Please try again later.',\r\n            retryAfter: 3600\r\n        })\r\n    },\r\n\r\n    // General API: 100 requests per 15 minutes\r\n    general: {\r\n        max: 100,\r\n        timeWindow: '15 minutes',\r\n        errorResponseBuilder: () => ({\r\n            error: 'Too Many Requests',\r\n            message: 'Rate limit exceeded. Please slow down.',\r\n            retryAfter: 900\r\n        })\r\n    }\r\n};\r\n\r\n/**\r\n * Custom key generator for rate limiting\r\n * Uses IP address + user ID if authenticated\r\n */\r\nexport function rateLimitKeyGenerator(request: FastifyRequest): string {\r\n    const ip = request.ip;\r\n    const userId = (request as any).user?.userId;\r\n\r\n    // Include user ID if authenticated to prevent one user from blocking others\r\n    return userId ? `${ip}:${userId}` : ip;\r\n}\r\n\r\n/**\r\n * Add Retry-After header on rate limit\r\n */\r\nexport function rateLimitErrorHandler(request: FastifyRequest, reply: FastifyReply) {\r\n    reply.code(429);\r\n    reply.header('Retry-After', '900'); // 15 minutes in seconds\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport crypto from 'crypto';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// Helper to generate 6 digit code\r\nconst generateOTP = () => Math.floor(100000 + Math.random() * 900000).toString();\r\n\r\nexport async function authOtpRoutes(fastify: FastifyInstance) {\r\n\r\n    // Send OTP\r\n    fastify.post('/auth/otp/send', async (request, reply) => {\r\n        const { email } = request.body as any;\r\n        if (!email) return reply.code(400).send({ error: \"Email required\" });\r\n\r\n        // Find or Create user (Passwordless flow supports both sign up and login)\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n\r\n        // If user doesn't exist, should we create them? \r\n        // For security, usually we only allow existing users or have a separate register flow.\r\n        // Let's assume for this \"Login with OTP\" feature, the user must exist.\r\n        if (!user) {\r\n            return reply.code(404).send({ error: \"User not found. Please sign up first.\" });\r\n        }\r\n\r\n        const otp = generateOTP();\r\n        const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 mins\r\n\r\n        await prisma.user.update({\r\n            where: { id: user.id },\r\n            data: {\r\n                otpCode: otp,\r\n                otpExpiresAt: expiresAt\r\n            }\r\n        });\r\n\r\n        // MOCK EMAIL SENDING\r\n        console.log(`\\x1b[33m[EMAIL MOCK] Sending OTP to ${email}: ${otp}\\x1b[0m`);\r\n\r\n        return { success: true, message: \"OTP sent to email.\" };\r\n    });\r\n\r\n    // Verify OTP\r\n    fastify.post('/auth/otp/verify', async (request, reply) => {\r\n        const { email, code } = request.body as any;\r\n\r\n        const user = await prisma.user.findUnique({ where: { email } });\r\n        if (!user) return reply.code(400).send({ error: \"User not found\" });\r\n\r\n        if (!user.otpCode || !user.otpExpiresAt) {\r\n            return reply.code(400).send({ error: \"No OTP requested\" });\r\n        }\r\n\r\n        if (new Date() > user.otpExpiresAt) {\r\n            return reply.code(400).send({ error: \"OTP expired\" });\r\n        }\r\n\r\n        if (user.otpCode !== code) {\r\n            return reply.code(400).send({ error: \"Invalid code\" });\r\n        }\r\n\r\n        // Success - Clear OTP\r\n        await prisma.user.update({\r\n            where: { id: user.id },\r\n            data: { otpCode: null, otpExpiresAt: null }\r\n        });\r\n\r\n        // Issue Session Token (Reuse existing Session logic if available, or just return mock token)\r\n        // Ideally we'd reuse the logic from auth.ts\r\n        // For now, let's return a simple success and assume frontend handles state\r\n\r\n        return {\r\n            success: true,\r\n            user: { id: user.id, email: user.email, name: user.name, role: user.role }\r\n        };\r\n    });\r\n}\r\n", "import { FastifyInstance } from \"fastify\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function workspaceRoutes(fastify: FastifyInstance) {\r\n  // List Workspaces\r\n  fastify.get(\"/workspaces\", async (request, reply) => {\r\n    // In real app: use request.user.id to filter\r\n    const workspaces = await prisma.workspace.findMany({\r\n      include: { owner: true },\r\n    });\r\n    return workspaces;\r\n  });\r\n\r\n  // Create Workspace\r\n  fastify.post(\"/workspaces\", async (request, reply) => {\r\n    const { name, description, ownerId } = request.body as any;\r\n\r\n    // Fallback if no ownerId sent (demo mode)\r\n    let finalOwnerId = ownerId;\r\n    if (!finalOwnerId) {\r\n      const firstUser = await prisma.user.findFirst();\r\n      if (!firstUser)\r\n        return reply\r\n          .code(400)\r\n          .send({ message: \"No users exist. Register first.\" });\r\n      finalOwnerId = firstUser.id;\r\n    }\r\n\r\n    const workspace = await prisma.workspace.create({\r\n      data: {\r\n        name,\r\n        description,\r\n        ownerId: finalOwnerId,\r\n        status: \"Starting\",\r\n      },\r\n    });\r\n\r\n    return workspace;\r\n  });\r\n\r\n  // Get Workspace Details\r\n  fastify.get(\"/workspaces/:id\", async (request, reply) => {\r\n    const { id } = request.params as any;\r\n    const workspace = await prisma.workspace.findUnique({\r\n      where: { id },\r\n      include: { owner: true },\r\n    });\r\n    return (\r\n      workspace || reply.code(404).send({ message: \"Workspace not found\" })\r\n    );\r\n  });\r\n\r\n  // Start Workspace IDE\r\n  fastify.post(\"/workspaces/:id/start\", async (request, reply) => {\r\n    const { id } = request.params as any;\r\n\r\n    // Ensure workspace exists first\r\n    const workspace = await prisma.workspace.findUnique({ where: { id } });\r\n    if (!workspace)\r\n      return reply.code(404).send({ message: \"Workspace not found\" });\r\n\r\n    try {\r\n      // Lazy load to avoid circular deps if any, though separate files usually fine\r\n      const { WorkspaceManager } = await import(\"../services/workspaceManager\");\r\n      const result = await WorkspaceManager.startWorkspace(id);\r\n\r\n      // Update status\r\n      await prisma.workspace.update({\r\n        where: { id },\r\n        data: { status: \"Running\" },\r\n      });\r\n\r\n      return result; // Returns { url: 'http://localhost:300X', port: 300X }\r\n    } catch (error: any) {\r\n      request.log.error(error);\r\n      return reply\r\n        .code(500)\r\n        .send({\r\n          message: \"Failed to start workspace environment\",\r\n          error: error.message,\r\n        });\r\n    }\r\n  });\r\n\r\n  // Update Status\r\n  fastify.patch(\"/workspaces/:id/status\", async (request, reply) => {\r\n    const { id } = request.params as any;\r\n    const { status } = request.body as any;\r\n\r\n    const workspace = await prisma.workspace.update({\r\n      where: { id },\r\n      data: { status },\r\n    });\r\n\r\n    return workspace;\r\n  });\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function repositoryRoutes(fastify: FastifyInstance) {\r\n\r\n    // List Repositories\r\n    fastify.get('/repositories', async (request, reply) => {\r\n        const repositories = await prisma.repository.findMany({\r\n            include: {\r\n                org: true,\r\n                securityAlerts: true // Include alerts summary\r\n            }\r\n        });\r\n        return repositories;\r\n    });\r\n\r\n    // Get Repository Details\r\n    fastify.get('/repositories/:id', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const repo = await prisma.repository.findUnique({\r\n            where: { id },\r\n            include: {\r\n                org: true,\r\n                securityAlerts: true,\r\n                aiTasks: true // Include AI tasks history\r\n            }\r\n        });\r\n\r\n        if (!repo) return reply.code(404).send({ message: 'Repository not found' });\r\n        return repo;\r\n    });\r\n\r\n    // Create Repository\r\n    fastify.post('/repositories', async (request, reply) => {\r\n        const { name, description, isPublic, techStack, orgId } = request.body as any;\r\n\r\n        const repo = await prisma.repository.create({\r\n            data: {\r\n                name,\r\n                description,\r\n                isPublic: isPublic || false,\r\n                language: techStack, // Mapping techStack to language for simplicity in this model\r\n                orgId: orgId, // Optional link to org\r\n                stars: 0,\r\n                forks: 0\r\n            }\r\n        });\r\n\r\n        return repo;\r\n    });\r\n\r\n    // Analyze Repository (AI Stub)\r\n    fastify.post('/repositories/:id/analyze', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n\r\n        // In a real app, this would trigger an async AI job\r\n        const task = await prisma.aITask.create({\r\n            data: {\r\n                repoId: id,\r\n                taskName: 'Code Quality Analysis',\r\n                model: 'DeepSeek-r1',\r\n                status: 'Processing',\r\n                result: null\r\n            }\r\n        });\r\n\r\n        return { message: 'Analysis started', taskId: task.id };\r\n    });\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// In-memory cache for Jobs List\r\nlet jobsCache: any = null;\r\nlet lastCacheUpdate = 0;\r\nconst CACHE_TTL = 30000; // 30 seconds\r\n\r\nexport async function jobRoutes(fastify: FastifyInstance) {\r\n\r\n    // List Jobs\r\n    fastify.get('/jobs', async (request, reply) => {\r\n        const now = Date.now();\r\n        if (jobsCache && (now - lastCacheUpdate < CACHE_TTL)) {\r\n            console.log(\"[Backend Cache] Serving jobs from memory\");\r\n            return jobsCache;\r\n        }\r\n\r\n        const jobs = await prisma.job.findMany({\r\n            include: {\r\n                creator: { select: { id: true, name: true, avatar: true } },\r\n                org: { select: { id: true, name: true, avatar: true } }\r\n            },\r\n            orderBy: { createdAt: 'desc' }\r\n        });\r\n\r\n        jobsCache = jobs;\r\n        lastCacheUpdate = now;\r\n        return jobs;\r\n    });\r\n\r\n    // Get Single Job\r\n    fastify.get('/jobs/:id', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const job = await prisma.job.findUnique({\r\n            where: { id },\r\n            include: {\r\n                creator: { select: { id: true, name: true, avatar: true } },\r\n                org: { select: { id: true, name: true, avatar: true } },\r\n                applications: {\r\n                    select: { id: true, status: true, applicantId: true } // Minimal data for checking status\r\n                }\r\n            }\r\n        });\r\n        if (!job) return reply.code(404).send({ message: 'Job not found' });\r\n        return job;\r\n    });\r\n\r\n    // Post a Job\r\n    fastify.post('/jobs', async (request, reply) => {\r\n        const { title, description, budget, type, techStack, creatorId, orgId, repoId } = request.body as any;\r\n\r\n        // Fallback creator for demo\r\n        let finalCreatorId = creatorId;\r\n        if (!finalCreatorId) {\r\n            const user = await prisma.user.findFirst();\r\n            if (!user) return reply.code(400).send({ message: 'No users found' });\r\n            finalCreatorId = user.id;\r\n        }\r\n\r\n        const job = await prisma.job.create({\r\n            data: {\r\n                title,\r\n                description,\r\n                budget,\r\n                type,\r\n                techStack: techStack || [], // Array of strings\r\n                status: 'Open',\r\n                creatorId: finalCreatorId,\r\n                orgId: orgId,\r\n                repositoryId: repoId\r\n            }\r\n        });\r\n\r\n        return job;\r\n    });\r\n\r\n    // Apply to Job\r\n    fastify.post('/jobs/:id/apply', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const { applicantId } = request.body as any;\r\n\r\n        if (!applicantId) return reply.code(400).send({ message: 'Applicant ID required' });\r\n\r\n        const existingApp = await prisma.jobApplication.findFirst({\r\n            where: { jobId: id, applicantId }\r\n        });\r\n\r\n        if (existingApp) return reply.code(409).send({ message: 'Already applied' });\r\n\r\n        const application = await prisma.jobApplication.create({\r\n            data: {\r\n                jobId: id,\r\n                applicantId,\r\n                status: 'Pending'\r\n            }\r\n        });\r\n\r\n        return { success: true, applicationId: application.id };\r\n    });\r\n    // Complete Job & Rate (Transaction)\r\n    fastify.post('/jobs/:id/complete', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const { rating, feedback, freelancerId } = request.body as any; // FreelancerId usually from accepted application\r\n\r\n        if (!rating || !freelancerId) return reply.code(400).send({ message: 'Missing rating or freelancerId' });\r\n\r\n        try {\r\n            const result = await prisma.$transaction(async (tx) => {\r\n                // 1. Close Job\r\n                const job = await tx.job.update({\r\n                    where: { id },\r\n                    data: { status: 'Completed' }\r\n                });\r\n\r\n                // Resolve Freelancer ID for \"Real Demo\" robustness\r\n                // If frontend sends a placeholder, we find a real user to make the data valid\r\n                let targetFreelancerId = freelancerId;\r\n                if (freelancerId === 'test-user-id-for-demo') {\r\n                    // Find a user who is NOT the creator\r\n                    const candidate = await tx.user.findFirst({\r\n                        where: { id: { not: job.creatorId } }\r\n                    });\r\n                    if (candidate) {\r\n                        targetFreelancerId = candidate.id;\r\n                    } else {\r\n                        // Fallback: Use creator if no one else exists (self-review for solo demo)\r\n                        targetFreelancerId = job.creatorId;\r\n                    }\r\n                }\r\n\r\n                // 2. Create Review\r\n                // Fallback reviewer (current user/session)\r\n                // Since this is real-time from UI, let's assume Job Creator is reviewing\r\n                const review = await tx.jobReview.create({\r\n                    data: {\r\n                        jobId: id,\r\n                        freelancerId: targetFreelancerId, // Actually links to FreelancerProfile.id? No, schema says FreelancerProfile\r\n                        reviewerId: job.creatorId,\r\n                        rating,\r\n                        comment: feedback\r\n                    }\r\n                });\r\n                // Wait, schema check: jobReview.freelancerId relations to FreelancerProfile.id?\r\n                // Schema: freelancer FreelancerProfile @relation...\r\n                // So we need the Profile ID, not User ID?\r\n                // Let's fetch FreelancerProfile first or use connect\r\n\r\n                // 3. Upsert Freelancer Profile & Update Stats\r\n                const freelancerProfile = await tx.freelancerProfile.upsert({\r\n                    where: { userId: targetFreelancerId }, // freelancerId param is likely the User ID\r\n                    create: {\r\n                        userId: targetFreelancerId,\r\n                        jobsCompleted: 1,\r\n                        rating: rating,\r\n                        isPublic: true\r\n                    },\r\n                    update: {\r\n                        jobsCompleted: { increment: 1 },\r\n                        // Recalculating average is tricky atomically with just update\r\n                        // Simplify: We will just update count here, and recalculate rating below\r\n                    }\r\n                });\r\n\r\n                // 4. Recalculate Rating (Weighted Average)\r\n                // Fetch all reviews for this profile\r\n                const allReviews = await tx.jobReview.findMany({\r\n                    where: { freelancerId: freelancerProfile.id }\r\n                });\r\n\r\n                const totalRating = allReviews.reduce((sum, r) => sum + r.rating, 0);\r\n                const avgRating = totalRating / allReviews.length;\r\n\r\n                await tx.freelancerProfile.update({\r\n                    where: { id: freelancerProfile.id },\r\n                    data: { rating: avgRating }\r\n                });\r\n\r\n                return { job, review, freelancerProfile };\r\n            });\r\n\r\n            return { success: true, data: result };\r\n\r\n        } catch (error) {\r\n            console.error(\"Complete Job Error:\", error);\r\n            return reply.code(500).send({ message: 'Failed to complete job', error });\r\n        }\r\n    });\r\n\r\n    // Dispute Job (Block Funds)\r\n    fastify.post('/jobs/:id/dispute', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const userId = request.headers['x-user-id'] || 'user-1';\r\n\r\n        const escrow = await prisma.escrowContract.findUnique({ where: { jobId: id } });\r\n        if (!escrow || escrow.status !== 'HELD') {\r\n            return reply.code(400).send({ error: \"No active escrow to dispute.\" });\r\n        }\r\n\r\n        const job = await prisma.job.findUnique({ where: { id } });\r\n        // Only Creator or Freelancer can dispute (Simplified check)\r\n\r\n        await prisma.escrowContract.update({\r\n            where: { id: escrow.id },\r\n            data: { status: 'DISPUTED' }\r\n        });\r\n\r\n        // Log it\r\n        // await prisma.transaction.create(...) // Optional log\r\n\r\n        return { success: true, message: \"Funds frozen. Support team notified.\" };\r\n    });\r\n\r\n\r\n    // Fund Job (Escrow)\r\n    fastify.post('/jobs/:id/fund', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const userId = request.headers['x-user-id'] || 'user-1'; // Employer\r\n\r\n        // 1. Get Job & Wallet\r\n        const job = await prisma.job.findUnique({ where: { id } });\r\n        if (!job) return reply.code(404).send({ error: \"Job not found\" });\r\n\r\n        const wallet = await prisma.wallet.findUnique({ where: { userId } });\r\n        if (!wallet) return reply.code(400).send({ error: \"Wallet not found. Please deposit funds first.\" });\r\n\r\n        // Parse Budget (Mock: assuming budget string like \"$500\")\r\n        // Robustness: strip non-numeric\r\n        const amount = parseFloat(job.budget?.replace(/[^0-9.]/g, '') || '0');\r\n        if (amount <= 0) return reply.code(400).send({ error: \"Invalid job budget to fund.\" });\r\n\r\n        if (wallet.balance < amount) {\r\n            return reply.code(402).send({ error: \"Insufficient funds.\" });\r\n        }\r\n\r\n        try {\r\n            await prisma.$transaction(async (tx) => {\r\n                // 1. Deduct from Wallet\r\n                await tx.wallet.update({\r\n                    where: { id: wallet.id },\r\n                    data: { balance: { decrement: amount } }\r\n                });\r\n\r\n                // 2. Create Transaction Log\r\n                await tx.transaction.create({\r\n                    data: {\r\n                        walletId: wallet.id,\r\n                        amount: -amount,\r\n                        type: 'ESCROW_HOLD',\r\n                        description: `Funded Escrow for Job: ${job.title}`,\r\n                        referenceId: job.id\r\n                    }\r\n                });\r\n\r\n                // 3. Create Escrow Contract\r\n                await tx.escrowContract.create({\r\n                    data: {\r\n                        jobId: job.id,\r\n                        amountLocked: amount,\r\n                        status: 'HELD'\r\n                    }\r\n                });\r\n\r\n                // 4. Update Job Status?\r\n                // await tx.job.update(...) // Optional\r\n            });\r\n\r\n            return { success: true, message: \"Funds secured in Escrow.\" };\r\n        } catch (e) {\r\n            console.error(e);\r\n            return reply.code(500).send({ error: \"Escrow failed.\" });\r\n        }\r\n    });\r\n\r\n    // Release Payment (Escrow -> Freelancer)\r\n    fastify.post('/jobs/:id/release', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        // In real app, check permission (only creator can release)\r\n\r\n        const escrow = await prisma.escrowContract.findUnique({ where: { jobId: id } });\r\n        if (!escrow || escrow.status !== 'HELD') {\r\n            return reply.code(400).send({ error: \"No active escrow funds found for this job.\" });\r\n        }\r\n\r\n        // Get Job to find freelancer (or pass in body)\r\n        // For Demo Phase 1: We accept 'freelancerId' in body, or derive from job\r\n        const { freelancerId } = request.body as any;\r\n        let targetUserId = freelancerId;\r\n\r\n        if (!targetUserId) {\r\n            // Try to find from Job Applications who was hired?\r\n            // For now, fail if not provided\r\n            return reply.code(400).send({ error: \"Target Freelancer ID required.\" });\r\n        }\r\n\r\n        try {\r\n            await prisma.$transaction(async (tx) => {\r\n                // 1. Update Escrow\r\n                await tx.escrowContract.update({\r\n                    where: { id: escrow.id },\r\n                    data: { status: 'RELEASED' }\r\n                });\r\n\r\n                // 2. Find/Create Freelancer Wallet\r\n                let fWallet = await tx.wallet.findUnique({ where: { userId: targetUserId } });\r\n                if (!fWallet) {\r\n                    fWallet = await tx.wallet.create({ data: { userId: targetUserId, balance: 0 } });\r\n                }\r\n\r\n                // 3. Credit Freelancer\r\n                await tx.wallet.update({\r\n                    where: { id: fWallet.id },\r\n                    data: { balance: { increment: escrow.amountLocked } }\r\n                });\r\n\r\n                // 4. Log Transaction (Freelancer)\r\n                await tx.transaction.create({\r\n                    data: {\r\n                        walletId: fWallet.id,\r\n                        amount: escrow.amountLocked,\r\n                        type: 'RELEASE',\r\n                        description: `Payment Released for Job #${id}`,\r\n                        referenceId: id\r\n                    }\r\n                });\r\n            });\r\n            return { success: true, message: \"Payment released to freelancer.\" };\r\n        } catch (e) {\r\n            console.error(e);\r\n            return reply.code(500).send({ error: \"Release failed.\" });\r\n        }\r\n    });\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { RoleGuard, OrgRole } from '../middleware/roles';\r\nimport { AuditService } from '../services/audit';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function orgRoutes(fastify: FastifyInstance) {\r\n\r\n    // Get My Organizations\r\n    fastify.get('/orgs', async (request, reply) => {\r\n        const userId = request.headers['x-user-id'] as string; // Mock Auth\r\n        if (!userId) return reply.code(401).send({ error: \"Unauthorized\" });\r\n\r\n        const members = await prisma.orgMember.findMany({\r\n            where: { userId },\r\n            include: { org: true }\r\n        });\r\n        return members.map(m => ({ ...m.org, role: m.role }));\r\n    });\r\n\r\n    // Create Organization\r\n    fastify.post('/orgs', async (request, reply) => {\r\n        const { name } = request.body as any;\r\n        const userId = request.headers['x-user-id'] as string;\r\n\r\n        const org = await prisma.organization.create({\r\n            data: { name }\r\n        });\r\n\r\n        // Add Creator as OWNER\r\n        await prisma.orgMember.create({\r\n            data: {\r\n                userId,\r\n                orgId: org.id,\r\n                role: 'OWNER' // Prisma Enum String\r\n            }\r\n        });\r\n\r\n        await AuditService.log(userId, 'ORG_CREATE', { name, orgId: org.id });\r\n        return org;\r\n    });\r\n\r\n    // Invite Member (RBAC: ADMIN or OWNER Only)\r\n    fastify.post('/orgs/:id/invite', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const { targetUserId, role } = request.body as any;\r\n        const userId = request.headers['x-user-id'] as string;\r\n\r\n        // 1. RBAC Check\r\n        const canInvite = await RoleGuard.hasRole(userId, id, OrgRole.ADMIN);\r\n        if (!canInvite) {\r\n            await AuditService.log(userId, 'ORG_INVITE_DENIED', { orgId: id, reason: 'Insufficient Permissions' });\r\n            return reply.code(403).send({ error: \"Access Denied: Admin role required.\" });\r\n        }\r\n\r\n        // 2. Add Member\r\n        try {\r\n            const membership = await prisma.orgMember.create({\r\n                data: {\r\n                    orgId: id,\r\n                    userId: targetUserId,\r\n                    role: role || 'MEMBER'\r\n                }\r\n            });\r\n\r\n            // 3. Log\r\n            await AuditService.log(userId, 'ORG_INVITE', { orgId: id, targetUserId, role });\r\n\r\n            return membership;\r\n        } catch (e) {\r\n            return reply.code(400).send({ error: \"User likely already a member.\" });\r\n        }\r\n    });\r\n\r\n    // Get Audit Logs (RBAC: OWNER Only)\r\n    fastify.get('/orgs/:id/logs', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const userId = request.headers['x-user-id'] as string;\r\n\r\n        const isOwner = await RoleGuard.isOwner(userId, id);\r\n        if (!isOwner) return reply.code(403).send({ error: \"Access Denied: Owner role required.\" });\r\n\r\n        // Fetch logs for this context?\r\n        // Our AuditService currently fetches by User. Ideally we filter by workspace/org if metadata supports it.\r\n        // For verify, we just return \"Access Granted\" msg or dummy logs\r\n        return { logs: [{ action: 'ORG_CREATE', timestamp: new Date() }] };\r\n    });\r\n}\r\n", "import { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport enum OrgRole {\r\n    OWNER = 'OWNER',\r\n    ADMIN = 'ADMIN',\r\n    MEMBER = 'MEMBER',\r\n    GUEST = 'GUEST'\r\n}\r\n\r\nexport const RoleHierarchy = {\r\n    [OrgRole.OWNER]: 4,\r\n    [OrgRole.ADMIN]: 3,\r\n    [OrgRole.MEMBER]: 2,\r\n    [OrgRole.GUEST]: 1\r\n};\r\n\r\nexport class RoleGuard {\r\n\r\n    // Check if user has at least the required role\r\n    static async hasRole(userId: string, orgId: string, requiredRole: OrgRole): Promise<boolean> {\r\n        const member = await prisma.orgMember.findUnique({\r\n            where: {\r\n                orgId_userId: {\r\n                    orgId,\r\n                    userId\r\n                }\r\n            }\r\n        });\r\n\r\n        if (!member) return false;\r\n\r\n        // \"member.role\" is a string from DB (or Enum if Prisma typed correctly), assuming Enum match\r\n        // But Prisma returns strings at runtime sometimes unless typed strictly.\r\n        // We cast to our local Enum or use the Hierarchy map.\r\n\r\n        const userLevel = RoleHierarchy[member.role as OrgRole] || 0;\r\n        const requiredLevel = RoleHierarchy[requiredRole];\r\n\r\n        return userLevel >= requiredLevel;\r\n    }\r\n\r\n    // specific check for Owner\r\n    static async isOwner(userId: string, orgId: string): Promise<boolean> {\r\n        return this.hasRole(userId, orgId, OrgRole.OWNER);\r\n    }\r\n}\r\n", "import { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport class AuditService {\r\n\r\n    static async log(userId: string, action: string, metadata: any = {}, workspaceId?: string, orgId?: string) {\r\n        try {\r\n            await prisma.activityLog.create({\r\n                data: {\r\n                    userId,\r\n                    action,\r\n                    metadata: { ...metadata, orgId },\r\n                    workspaceId,\r\n                    createdAt: new Date()\r\n                }\r\n            });\r\n            console.log(`\\x1b[36m[AUDIT] ${userId} performed ${action}\\x1b[0m`);\r\n        } catch (e) {\r\n            console.error(\"Failed to write audit log\", e);\r\n        }\r\n    }\r\n\r\n    static async getLogs(userId: string) {\r\n        // Only fetch logs relevant to this user (or if admin, fetch all?)\r\n        // For now, fetch user's own logs\r\n        return prisma.activityLog.findMany({\r\n            where: { userId },\r\n            orderBy: { createdAt: 'desc' },\r\n            take: 100\r\n        });\r\n    }\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function communityRoutes(fastify: FastifyInstance) {\r\n\r\n    // List Posts\r\n    fastify.get('/community/posts', async (request, reply) => {\r\n        const posts = await prisma.communityPost.findMany({\r\n            include: {\r\n                author: { select: { id: true, name: true, avatar: true } },\r\n                comments: true\r\n            },\r\n            orderBy: { createdAt: 'desc' }\r\n        });\r\n        return posts;\r\n    });\r\n\r\n    // Create Post\r\n    fastify.post('/community/posts', async (request, reply) => {\r\n        const { title, content, authorId } = request.body as any;\r\n\r\n        if (!authorId) return reply.code(400).send({ message: 'Author ID required' });\r\n\r\n        const post = await prisma.communityPost.create({\r\n            data: {\r\n                title,\r\n                content,\r\n                authorId\r\n            }\r\n        });\r\n\r\n        return post;\r\n    });\r\n\r\n    // Add Comment\r\n    fastify.post('/community/posts/:id/comments', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        const { text, authorId } = request.body as any;\r\n\r\n        const comment = await prisma.communityComment.create({\r\n            data: {\r\n                postId: id,\r\n                text,\r\n                authorId\r\n            }\r\n        });\r\n\r\n        return comment;\r\n    });\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// In-memory cache for heatmaps\r\nconst heatmapCache = new Map<string, { data: any, timestamp: number }>();\r\nconst HEATMAP_TTL = 60000; // 1 minute\r\n\r\nexport async function profileRoutes(fastify: FastifyInstance) {\r\n\r\n    // Get Full Profile\r\n    fastify.get('/profile/:username', async (request, reply) => {\r\n        const { username } = request.params as any;\r\n\r\n        // Find User\r\n        const user = await prisma.user.findUnique({\r\n            where: { username },\r\n            include: {\r\n                profile: { include: { socialLinks: true } },\r\n                relations: false // skipping for brevity\r\n            }\r\n        });\r\n\r\n        if (!user) return reply.code(404).send({ message: 'User not found' });\r\n\r\n        // Fetch Freelancer Stats (Separate query usually better)\r\n        const freelancerProfile = await prisma.freelancerProfile.findUnique({\r\n            where: { userId: user.id },\r\n            include: { reviews: true }\r\n        });\r\n\r\n        return {\r\n            user,\r\n            freelancerProfile\r\n        };\r\n    });\r\n\r\n    // exact GitHub-parity Heatmap API\r\n    fastify.get('/profile/:username/contributions', async (request, reply) => {\r\n        const { username } = request.params as any;\r\n\r\n        const now = Date.now();\r\n        const cached = heatmapCache.get(username);\r\n        if (cached && (now - cached.timestamp < HEATMAP_TTL)) {\r\n            console.log(`[Cache] Serving heatmap for ${username}`);\r\n            return cached.data;\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({ where: { username } });\r\n        if (!user) return reply.code(404).send({ message: 'User not found' });\r\n\r\n        // Fetch pre-aggregated data\r\n        const dailyData = await prisma.dailyContribution.findMany({\r\n            where: { userId: user.id },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const total = dailyData.reduce((acc, curr) => acc + curr.count, 0);\r\n\r\n        // Determine date range (one year)\r\n        const toDate = new Date();\r\n        const fromDate = new Date();\r\n        fromDate.setFullYear(fromDate.getFullYear() - 1);\r\n\r\n        const result = {\r\n            total_contributions: total,\r\n            from: fromDate.toISOString().split('T')[0],\r\n            to: toDate.toISOString().split('T')[0],\r\n            contributions: dailyData.map(d => ({\r\n                date: d.date,\r\n                count: d.count,\r\n                level: d.level\r\n            }))\r\n        };\r\n\r\n        heatmapCache.set(username, { data: result, timestamp: now });\r\n        return result;\r\n    });\r\n\r\n    // Get Activity Heatmap Data\r\n    fastify.get('/profile/:username/heatmap', async (request, reply) => {\r\n        const { username } = request.params as any;\r\n        const user = await prisma.user.findUnique({ where: { username } });\r\n        if (!user) return reply.code(404).send({ message: 'User not found' });\r\n\r\n        // Aggregate counts by day (Postgres-specific or manual grouping)\r\n        // For MVP, fetch all logs for last year and map in JS (Not optimal for huge scale, fine for initial version)\r\n        const oneYearAgo = new Date();\r\n        oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\r\n\r\n        const logs = await prisma.activityLog.findMany({\r\n            where: {\r\n                userId: user.id,\r\n                createdAt: { gte: oneYearAgo }\r\n            },\r\n            select: { createdAt: true, action: true }\r\n        });\r\n\r\n        // Grouping logic return\r\n        return { logs, total: logs.length };\r\n    });\r\n\r\n    // Get AI Usage Analytics\r\n    fastify.get('/profile/:username/ai-usage', async (request, reply) => {\r\n        const { username } = request.params as any;\r\n        const user = await prisma.user.findUnique({ where: { username } });\r\n        if (!user) return reply.code(404).send({ message: 'User not found' });\r\n\r\n        const logs = await prisma.aIUsageLog.findMany({\r\n            where: { userId: user.id },\r\n            orderBy: { createdAt: 'desc' },\r\n            take: 100 // Limit for now\r\n        });\r\n\r\n        // Calculate totals\r\n        const totalTokens = await prisma.aIUsageLog.aggregate({\r\n            where: { userId: user.id },\r\n            _sum: { tokensUsed: true }\r\n        });\r\n\r\n        return { logs, totalTokens: totalTokens._sum.tokensUsed || 0 };\r\n    });\r\n\r\n    // Real-time Activity Logger\r\n    fastify.post('/profile/activity', async (request, reply) => {\r\n        const { username, action, metadata } = request.body as any;\r\n\r\n        // 1. Get User\r\n        const user = await prisma.user.findUnique({ where: { username } });\r\n        if (!user) {\r\n            // For prototype without full auth flow, we might auto-create or error\r\n            // Let's assume user exists or use the first one fallback\r\n            const firstUser = await prisma.user.findFirst();\r\n            if (!firstUser) return reply.code(400).send({ message: 'No users found' });\r\n            // Use first user if specific one not found (Demo resilience)\r\n            var userId = firstUser.id;\r\n        } else {\r\n            var userId = user.id;\r\n        }\r\n\r\n        // 2. Log Activity\r\n        await prisma.activityLog.create({\r\n            data: {\r\n                userId,\r\n                action,\r\n                metadata: metadata || {}\r\n            }\r\n        });\r\n\r\n        // 3. Update Daily Aggregation\r\n        const today = new Date().toISOString().split('T')[0];\r\n\r\n        const daily = await prisma.dailyContribution.upsert({\r\n            where: {\r\n                userId_date: { userId, date: today }\r\n            },\r\n            create: {\r\n                userId,\r\n                date: today,\r\n                count: 1,\r\n                level: 1\r\n            },\r\n            update: {\r\n                count: { increment: 1 }\r\n            }\r\n        });\r\n\r\n        // 4. Update Level (Simple Logic: 1-5 actions=1, 6-10=2, 11-15=3, 15+=4)\r\n        // In a real app, this would be relative to max, but for instant feedback:\r\n        let newLevel = 1;\r\n        if (daily.count >= 5) newLevel = 2;\r\n        if (daily.count >= 10) newLevel = 3;\r\n        if (daily.count >= 15) newLevel = 4;\r\n\r\n        await prisma.dailyContribution.update({\r\n            where: { id: daily.id },\r\n            data: { level: newLevel }\r\n        });\r\n\r\n        return { success: true, count: daily.count };\r\n    });\r\n\r\n    // Updated SEED Endpoint\r\n    fastify.post('/profile/seed-stats', async (request, reply) => {\r\n        const { userId } = request.body as any;\r\n        if (!userId) return reply.code(400).send({ message: 'UserId required' });\r\n\r\n        // 1. Clear old data\r\n        await prisma.dailyContribution.deleteMany({ where: { userId } });\r\n        await prisma.activityLog.deleteMany({ where: { userId } });\r\n\r\n        // 2. Generate activity\r\n        const dailyMap: Record<string, number> = {};\r\n        const now = new Date();\r\n\r\n        const logs = [];\r\n        for (let i = 0; i < 500; i++) {\r\n            // Weighted random date\r\n            const offset = Math.floor(Math.random() * 365);\r\n            const date = new Date(now.getTime() - offset * 24 * 60 * 60 * 1000);\r\n            const dateStr = date.toISOString().split('T')[0];\r\n\r\n            logs.push({\r\n                userId,\r\n                action: 'commit',\r\n                createdAt: date,\r\n                metadata: {}\r\n            });\r\n\r\n            dailyMap[dateStr] = (dailyMap[dateStr] || 0) + 1;\r\n        }\r\n\r\n        // Insert Logs\r\n        await prisma.activityLog.createMany({ data: logs });\r\n\r\n        // 3. Compute Levels & Insert Daily\r\n        // Simple quartile logic: max count -> scale\r\n        const maxCount = Math.max(...Object.values(dailyMap), 1);\r\n\r\n        const contributions = Object.entries(dailyMap).map(([date, count]) => {\r\n            let level = 0;\r\n            if (count > 0) level = 1;\r\n            if (count >= maxCount * 0.25) level = 2;\r\n            if (count >= maxCount * 0.5) level = 3;\r\n            if (count >= maxCount * 0.75) level = 4;\r\n\r\n            return { userId, date, count, level };\r\n        });\r\n\r\n        await prisma.dailyContribution.createMany({ data: contributions });\r\n\r\n        return { success: true, message: 'Seeded aggregated analytics' };\r\n    });\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { DockerService } from '../services/docker';\r\nimport { TerminalService } from '../services/terminal';\r\nimport path from 'path';\r\nimport fs from 'fs/promises';\r\n\r\nexport async function forgeRoutes(fastify: FastifyInstance) {\r\n\r\n    // Terminal WebSocket\r\n    fastify.get('/forge/terminal/:workspaceId', { websocket: true }, (connection, req) => {\r\n        TerminalService.handleConnection(connection, req).catch(err => {\r\n            fastify.log.error(\"Terminal WebSocket Error: \" + err.message);\r\n        });\r\n    });\r\n\r\n    // Create Workspace (Docker Container + Local Folder)\r\n    fastify.post('/forge/create', async (request, reply) => {\r\n        const { workspaceId, framework } = request.body as any;\r\n\r\n        try {\r\n            const result = await DockerService.createContainer(workspaceId, 'node:18-alpine');\r\n\r\n            // Create initial file\r\n            const wsPath = path.resolve(__dirname, `../../workspaces/${workspaceId}`);\r\n            await fs.writeFile(path.join(wsPath, 'index.js'), '// Start coding here\\nconsole.log(\"Hello from The Forge!\");');\r\n\r\n            return { success: true, containerId: result.containerId };\r\n        } catch (e: any) {\r\n            console.error(\"Workspace Creation Error:\", e);\r\n            return reply.code(500).send({ error: \"Failed to create workspace\" });\r\n        }\r\n    });\r\n\r\n    // File System API\r\n    fastify.get('/forge/files/:workspaceId', async (request, reply) => {\r\n        const { workspaceId } = request.params as any;\r\n        const rootPath = path.resolve(__dirname, `../../workspaces/${workspaceId}`);\r\n\r\n        // Recursive file tree (Simplified for demo)\r\n        const getFiles = async (dir: string): Promise<any[]> => {\r\n            const dirents = await fs.readdir(dir, { withFileTypes: true });\r\n            const files = await Promise.all(dirents.map((dirent) => {\r\n                const res = path.resolve(dir, dirent.name);\r\n                return dirent.isDirectory() ? getFiles(res) : res;\r\n            }));\r\n            return Array.prototype.concat(...files);\r\n        };\r\n\r\n        try {\r\n            const files = await getFiles(rootPath);\r\n            // Convert to relative paths\r\n            return files.map(f => f.replace(rootPath, '').replace(/\\\\/g, '/'));\r\n        } catch (e) {\r\n            return [];\r\n        }\r\n    });\r\n\r\n    // Read File Content\r\n    fastify.get('/forge/files/:workspaceId/content', async (request, reply) => {\r\n        const { workspaceId } = request.params as any;\r\n        const { path: filePath } = request.query as any;\r\n\r\n        if (!filePath) return reply.code(400).send({ error: \"File path required\" });\r\n\r\n        // Security: Prevent directory traversal\r\n        if (filePath.includes('..')) return reply.code(403).send({ error: \"Invalid path\" });\r\n\r\n        const fullPath = path.resolve(__dirname, `../../workspaces/${workspaceId}`, filePath);\r\n\r\n        try {\r\n            const content = await fs.readFile(fullPath, 'utf-8');\r\n            return { content };\r\n        } catch (e) {\r\n            return reply.code(404).send({ error: \"File not found\" });\r\n        }\r\n    });\r\n\r\n    // Write File Content\r\n    fastify.post('/forge/files/:workspaceId/save', async (request, reply) => {\r\n        const { workspaceId } = request.params as any;\r\n        const { path: filePath, content } = request.body as any;\r\n\r\n        if (!filePath || content === undefined) return reply.code(400).send({ error: \"Path and content required\" });\r\n        if (filePath.includes('..')) return reply.code(403).send({ error: \"Invalid path\" });\r\n\r\n        const fullPath = path.resolve(__dirname, `../../workspaces/${workspaceId}`, filePath);\r\n\r\n        try {\r\n            await fs.writeFile(fullPath, content);\r\n            return { success: true };\r\n        } catch (e) {\r\n            return reply.code(500).send({ error: \"Failed to save file\" });\r\n        }\r\n    });\r\n\r\n    // Git Push Guard (Governance Logic)\r\n    fastify.post('/forge/git/push', async (request, reply) => {\r\n        const { repoId, userId } = request.body as any;\r\n\r\n        // Mock Repository Governance Check\r\n        // In real app, we check DB: prisma.repository.findUnique(...)\r\n\r\n        // Simulating logic based on \"Solo\" vs \"Team\"\r\n        // Let's check a mock \"contributors\" count. \r\n        // If repoId ends in 'solo', we treat as solo. Else team.\r\n\r\n        const isSoloRepo = repoId.endsWith('-solo');\r\n\r\n        if (isSoloRepo) {\r\n            return { success: true, message: \"Push allowed (Solo Developer Mode).\" };\r\n        } else {\r\n            // Team Mode -> Check for Approved PR\r\n            // Mock: We fail unless 'prStatus' is approved\r\n            const { prStatus } = request.body as any;\r\n\r\n            if (prStatus !== 'APPROVED') {\r\n                return reply.code(403).send({\r\n                    error: \"Push Rejected: Admin Approval Required.\",\r\n                    details: \"This repository is in Team Mode. Direct pushes are blocked. Please submit a Pull Request and wait for Admin Approval (AHI Risk Score check).\"\r\n                });\r\n            }\r\n\r\n            return { success: true, message: \"Push allowed (PR Approved).\" };\r\n        }\r\n    });\r\n}\r\n", "import { FastifyRequest } from 'fastify';\r\nimport { createRequire } from 'module';\r\nconst require = createRequire(import.meta.url);\r\nconst Docker = require('dockerode');\r\nimport process from 'process';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\nconst docker = new Docker(\r\n    process.platform === 'win32'\r\n        ? { socketPath: '//./pipe/docker_engine' }\r\n        : undefined\r\n);\r\n\r\nconst LOG_FILE = path.join(process.cwd(), 'terminal-error.log');\r\n\r\nexport class TerminalService {\r\n    static async handleConnection(connection: any, req: FastifyRequest) {\r\n        const { workspaceId } = req.params as any;\r\n\r\n        // Fastify 5 / @fastify/websocket handling\r\n        // connection is a SocketStream, connection.socket is the raw WebSocket\r\n        const socket = connection.socket || connection;\r\n\r\n        console.log(`\uD83D\uDD0C Terminal connection attempt for workspace: ${workspaceId}`);\r\n        fs.appendFileSync(LOG_FILE, `\\n--- Connection: ${new Date().toISOString()} ---\\n`);\r\n\r\n        if (!socket || typeof socket.on !== 'function') {\r\n            const errorMsg = \"Critical: No valid WebSocket found on connection object.\";\r\n            console.error(errorMsg);\r\n            fs.appendFileSync(LOG_FILE, `${errorMsg}\\nConnection keys: ${Object.keys(connection || {})}\\n`);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const containerName = `trackcodex-${workspaceId}`;\r\n            const container = docker.getContainer(containerName);\r\n\r\n            // Verify container status\r\n            try {\r\n                await container.inspect();\r\n            } catch (err: any) {\r\n                fs.appendFileSync(LOG_FILE, `Inspect failed: ${err.message}\\n`);\r\n                socket.send('\\r\\n\\x1b[31m[System] Container not found or not running.\\x1b[0m\\r\\n');\r\n                socket.close();\r\n                return;\r\n            }\r\n\r\n            // Create and start exec\r\n            const exec = await container.exec({\r\n                AttachStdin: true,\r\n                AttachStdout: true,\r\n                AttachStderr: true,\r\n                Tty: true,\r\n                Cmd: ['sh']\r\n            });\r\n\r\n            const stream = await exec.start({\r\n                hijack: true,\r\n                stdin: true\r\n            });\r\n\r\n            if (!stream) {\r\n                throw new Error(\"Terminal stream could not be initialized.\");\r\n            }\r\n\r\n            // Docker Stream -> WebSocket\r\n            stream.on('data', (chunk: Buffer) => {\r\n                if (socket.readyState === 1) { // OPEN\r\n                    socket.send(chunk.toString('utf-8'));\r\n                }\r\n            });\r\n\r\n            stream.on('error', (err: any) => {\r\n                fs.appendFileSync(LOG_FILE, `Docker Stream Error: ${err.stack}\\n`);\r\n                if (socket.readyState === 1) socket.close();\r\n            });\r\n\r\n            stream.on('end', () => {\r\n                if (socket.readyState === 1) {\r\n                    socket.send('\\r\\n[System] Session ended.\\r\\n');\r\n                    socket.close();\r\n                }\r\n            });\r\n\r\n            // WebSocket -> Docker Stream\r\n            socket.on('message', (data: any) => {\r\n                if (stream && stream.writable) {\r\n                    stream.write(data.toString());\r\n                }\r\n            });\r\n\r\n            socket.on('close', () => {\r\n                fs.appendFileSync(LOG_FILE, `WebSocket closed by client.\\n`);\r\n                if (stream) stream.end();\r\n            });\r\n\r\n            socket.on('error', (err: any) => {\r\n                fs.appendFileSync(LOG_FILE, `WebSocket Error: ${err.stack}\\n`);\r\n            });\r\n\r\n            socket.send('\\r\\n\\x1b[32m[System] Terminal ready.\\x1b[0m\\r\\n$ ');\r\n\r\n        } catch (error: any) {\r\n            fs.appendFileSync(LOG_FILE, `Fatal Error: ${error.stack}\\n`);\r\n            console.error(\"Terminal Failure (logged)\");\r\n            if (socket.readyState === 1) {\r\n                socket.send(`\\r\\n\\x1b[31m[Critical Error] ${error.message}\\x1b[0m\\r\\n`);\r\n                socket.close();\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { PrismaClient } from '@prisma/client';\r\nimport { ChatService } from './chat';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport class NotificationService {\r\n\r\n    // Create & Broadcast\r\n    static async create(userId: string, type: string, title: string, message: string) {\r\n        try {\r\n            // 1. Save to DB\r\n            const notif = await prisma.notification.create({\r\n                data: {\r\n                    userId,\r\n                    type,\r\n                    title,\r\n                    message,\r\n                    read: false\r\n                }\r\n            });\r\n\r\n            // 2. Push via WebSocket (Using ChatService's connection map)\r\n            ChatService.sendNotification(userId, notif);\r\n\r\n            return notif;\r\n        } catch (e) {\r\n            console.error(\"Failed to create notification\", e);\r\n        }\r\n    }\r\n\r\n    // Get All for User\r\n    static async getAll(userId: string) {\r\n        return prisma.notification.findMany({\r\n            where: { userId },\r\n            orderBy: { createdAt: 'desc' }\r\n        });\r\n    }\r\n\r\n    // Mark as Read\r\n    static async markRead(id: string) {\r\n        return prisma.notification.update({\r\n            where: { id },\r\n            data: { read: true }\r\n        });\r\n    }\r\n\r\n    // Mark All Read\r\n    static async markAllRead(userId: string) {\r\n        return prisma.notification.updateMany({\r\n            where: { userId, read: false },\r\n            data: { read: true }\r\n        });\r\n    }\r\n}\r\n", "import { SocketStream } from '@fastify/websocket';\r\nimport { FastifyRequest, FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { WebSocket } from 'ws';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\n// In-memory store of connected users: userId -> WebSocket[]\r\nconst connections = new Map<string, Set<WebSocket>>();\r\n\r\nexport class ChatService {\r\n\r\n    static async handleConnection(connection: SocketStream, req: FastifyRequest) {\r\n        const socket = connection.socket;\r\n        // In real app, extract userId from JWT token in query/headers\r\n        // For demo, we pass userId in query param: /api/v1/chat?userId=...\r\n        const { userId } = req.query as any;\r\n\r\n        if (!userId) {\r\n            socket.close();\r\n            return;\r\n        }\r\n\r\n        console.log(`\uD83D\uDCAC User connected to Chat: ${userId}`);\r\n\r\n        // Add to connections\r\n        if (!connections.has(userId)) {\r\n            connections.set(userId, new Set());\r\n        }\r\n        connections.get(userId)!.add(socket);\r\n\r\n        // Handle Messages\r\n        socket.on('message', async (data: string) => {\r\n            try {\r\n                const payload = JSON.parse(data.toString());\r\n\r\n                // Expect { type: 'dm', receiverId: '...', content: '...' }\r\n                if (payload.type === 'dm') {\r\n                    const { receiverId, content } = payload;\r\n\r\n                    // 1. Save to DB\r\n                    const msg = await prisma.message.create({\r\n                        data: {\r\n                            senderId: userId,\r\n                            receiverId,\r\n                            content\r\n                        }\r\n                    });\r\n\r\n                    // 2. Send to Receiver (if online)\r\n                    const receiverSockets = connections.get(receiverId);\r\n                    if (receiverSockets) {\r\n                        receiverSockets.forEach(client => {\r\n                            if (client.readyState === WebSocket.OPEN) {\r\n                                client.send(JSON.stringify({\r\n                                    type: 'dm',\r\n                                    message: msg\r\n                                }));\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // 3. Send confirmation to Sender (optional, or just rely on optimistic UI)\r\n                    socket.send(JSON.stringify({ type: 'ack', id: msg.id }));\r\n                }\r\n\r\n            } catch (e) {\r\n                console.error(\"Chat Error:\", e);\r\n            }\r\n        });\r\n\r\n        socket.on('close', () => {\r\n            const userConns = connections.get(userId);\r\n            if (userConns) {\r\n                userConns.delete(socket);\r\n                if (userConns.size === 0) connections.delete(userId);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Helper to send system notification\r\n    static sendNotification(userId: string, notification: any) {\r\n        const userConns = connections.get(userId);\r\n        if (userConns) {\r\n            userConns.forEach(client => {\r\n                if (client.readyState === WebSocket.OPEN) {\r\n                    client.send(JSON.stringify({ type: 'notification', data: notification }));\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { NotificationService } from '../services/notification';\r\n\r\nexport async function notificationRoutes(fastify: FastifyInstance) {\r\n\r\n    // Get My Notifications\r\n    fastify.get('/notifications', async (request, reply) => {\r\n        const { userId } = request.query as any; // In real app, from Token\r\n        if (!userId) return reply.code(400).send({ error: \"UserId required\" });\r\n\r\n        const list = await NotificationService.getAll(userId);\r\n        return list;\r\n    });\r\n\r\n    // Mark Read\r\n    fastify.post('/notifications/:id/read', async (request, reply) => {\r\n        const { id } = request.params as any;\r\n        await NotificationService.markRead(id);\r\n        return { success: true };\r\n    });\r\n\r\n    // Mark All Read\r\n    fastify.post('/notifications/read-all', async (request, reply) => {\r\n        const { userId } = request.body as any;\r\n        await NotificationService.markAllRead(userId);\r\n        return { success: true };\r\n    });\r\n}\r\n", "\r\nimport { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { requireAuth, requireRole } from '../middleware/auth';\r\nimport { logSensitiveOperation } from '../services/auditLogger';\r\nimport { revokeAllUserSessions } from '../services/session';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function adminRoutes(fastify: FastifyInstance) {\r\n\r\n    // Protect all admin routes\r\n    fastify.addHook('preHandler', requireRole('admin'));\r\n\r\n    // List Users (Paginated & Searchable)\r\n    fastify.get('/admin/users', async (request, reply) => {\r\n        const { page = 1, limit = 20, search } = request.query as any;\r\n        const skip = (Number(page) - 1) * Number(limit);\r\n\r\n        try {\r\n            const whereClause = search ? {\r\n                OR: [\r\n                    { email: { contains: search } },\r\n                    { username: { contains: search } }\r\n                ]\r\n            } : {};\r\n\r\n            const [users, total] = await Promise.all([\r\n                prisma.user.findMany({\r\n                    where: whereClause,\r\n                    skip,\r\n                    take: Number(limit),\r\n                    orderBy: { createdAt: 'desc' },\r\n                    select: {\r\n                        id: true,\r\n                        email: true,\r\n                        username: true,\r\n                        role: true,\r\n                        accountLocked: true,\r\n                        createdAt: true,\r\n                        _count: { select: { sessions: true } }\r\n                    }\r\n                }),\r\n                prisma.user.count({ where: whereClause })\r\n            ]);\r\n\r\n            return {\r\n                data: users,\r\n                meta: {\r\n                    total,\r\n                    page: Number(page),\r\n                    limit: Number(limit),\r\n                    pages: Math.ceil(total / Number(limit))\r\n                }\r\n            };\r\n        } catch (error) {\r\n            request.log.error(error);\r\n            return reply.code(500).send({ error: 'Failed to fetch users' });\r\n        }\r\n    });\r\n\r\n    // Ban User\r\n    fastify.post('/admin/users/:userId/ban', async (request, reply) => {\r\n        const { userId } = request.params as { userId: string };\r\n        const { reason } = request.body as { reason?: string };\r\n        const adminUser = (request as any).user;\r\n\r\n        try {\r\n            // Prevent self-ban\r\n            if (userId === adminUser.userId) {\r\n                return reply.code(400).send({ error: 'Cannot ban yourself' });\r\n            }\r\n\r\n            // Lock account\r\n            const updatedUser = await prisma.user.update({\r\n                where: { id: userId },\r\n                data: { accountLocked: true }\r\n            });\r\n\r\n            // Revoke sessions\r\n            await revokeAllUserSessions(userId);\r\n\r\n            // Audit\r\n            await logSensitiveOperation(\r\n                adminUser.userId,\r\n                'ban_user',\r\n                'user',\r\n                userId,\r\n                request.ip,\r\n                request.headers['user-agent'] || 'system',\r\n                true,\r\n                { reason }\r\n            );\r\n\r\n            return { message: `User ${updatedUser.email} has been banned and sessions revoked.` };\r\n        } catch (error) {\r\n            request.log.error(error);\r\n            return reply.code(500).send({ error: 'Failed to ban user' });\r\n        }\r\n    });\r\n\r\n    // Unban User\r\n    fastify.post('/admin/users/:userId/unban', async (request, reply) => {\r\n        const { userId } = request.params as { userId: string };\r\n        const adminUser = (request as any).user;\r\n\r\n        try {\r\n            await prisma.user.update({\r\n                where: { id: userId },\r\n                data: { accountLocked: false }\r\n            });\r\n\r\n            await logSensitiveOperation(\r\n                adminUser.userId,\r\n                'unban_user',\r\n                'user',\r\n                userId,\r\n                request.ip,\r\n                request.headers['user-agent'] || 'system',\r\n                true\r\n            );\r\n\r\n            return { message: 'User unbanned' };\r\n        } catch (error) {\r\n            request.log.error(error);\r\n            return reply.code(500).send({ error: 'Failed to unban user' });\r\n        }\r\n    });\r\n}\r\n", "\r\nimport { FastifyInstance } from 'fastify';\r\nimport { PrismaClient } from '@prisma/client';\r\nimport { requireAuth } from '../middleware/auth';\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nexport async function searchRoutes(fastify: FastifyInstance) {\r\n\r\n    // Global Search Endpoint\r\n    // GET /api/v1/search?q=query\r\n    fastify.get('/search', { preHandler: requireAuth }, async (request, reply) => {\r\n        const { q } = request.query as { q: string };\r\n        const user = (request as any).user;\r\n\r\n        if (!q || q.length < 2) {\r\n            return { results: [] };\r\n        }\r\n\r\n        const query = q.toLowerCase();\r\n\r\n        try {\r\n            // Search in parallel across main entities\r\n            const [users, orgs, repos, workspaces, jobs] = await Promise.all([\r\n\r\n                // 1. Users (People)\r\n                prisma.user.findMany({\r\n                    where: {\r\n                        OR: [\r\n                            { name: { contains: query } }, // Case insensitive in standard SQL, Prisma standard depends on DB\r\n                            { username: { contains: query } },\r\n                            { email: { contains: query } }\r\n                        ]\r\n                    },\r\n                    take: 5,\r\n                    select: { id: true, name: true, username: true, avatar: true }\r\n                }),\r\n\r\n                // 2. Organizations\r\n                prisma.organization.findMany({\r\n                    where: { name: { contains: query } },\r\n                    take: 5,\r\n                    select: { id: true, name: true }\r\n                }),\r\n\r\n                // 3. Repositories (Public or member of Org)\r\n                // For simplicity: All public + explicit checks ideally\r\n                prisma.repository.findMany({\r\n                    where: {\r\n                        OR: [\r\n                            { name: { contains: query } },\r\n                            { description: { contains: query } }\r\n                        ],\r\n                        // isPublic: true // Assume public for search scope in this demo\r\n                    },\r\n                    take: 5,\r\n                    select: { id: true, name: true, description: true }\r\n                }),\r\n\r\n                // 4. Workspaces (Owned by user)\r\n                prisma.workspace.findMany({\r\n                    where: {\r\n                        ownerId: user.userId,\r\n                        name: { contains: query }\r\n                    },\r\n                    take: 5,\r\n                    select: { id: true, name: true, status: true }\r\n                }),\r\n\r\n                // 5. Jobs\r\n                prisma.job.findMany({\r\n                    where: {\r\n                        OR: [\r\n                            { title: { contains: query } },\r\n                            { description: { contains: query } }\r\n                        ]\r\n                    },\r\n                    take: 5,\r\n                    select: { id: true, title: true, budget: true, type: true }\r\n                })\r\n            ]);\r\n\r\n            // Format results for CommandPalette\r\n            const results = [\r\n                ...orgs.map(o => ({\r\n                    id: `org-${o.id}`,\r\n                    type: 'org',\r\n                    label: o.name,\r\n                    icon: 'domain',\r\n                    group: 'Organizations',\r\n                    url: `/org/${o.id}`\r\n                })),\r\n                ...repos.map(r => ({\r\n                    id: `repo-${r.id}`,\r\n                    type: 'repo',\r\n                    label: r.name,\r\n                    subLabel: r.description,\r\n                    icon: 'book',\r\n                    group: 'Repositories',\r\n                    url: `/repo/${r.id}`\r\n                })),\r\n                ...workspaces.map(w => ({\r\n                    id: `ws-${w.id}`,\r\n                    type: 'workspace',\r\n                    label: w.name,\r\n                    subLabel: w.status,\r\n                    icon: 'terminal',\r\n                    group: 'Workspaces',\r\n                    url: `/workspace/${w.id}`\r\n                })),\r\n                ...jobs.map(j => ({\r\n                    id: `job-${j.id}`,\r\n                    type: 'job',\r\n                    label: j.title,\r\n                    subLabel: `${j.type} - ${j.budget}`,\r\n                    icon: 'work',\r\n                    group: 'Jobs',\r\n                    url: `/jobs/${j.id}`\r\n                })),\r\n                ...users.map(u => ({\r\n                    id: `user-${u.id}`,\r\n                    type: 'user',\r\n                    label: u.name || u.username || 'User',\r\n                    subLabel: u.username,\r\n                    icon: 'person',\r\n                    group: 'People',\r\n                    url: `/profile/${u.username}`\r\n                }))\r\n            ];\r\n\r\n            return { results };\r\n\r\n        } catch (error) {\r\n            request.log.error(error);\r\n            return reply.code(500).send({ error: 'Search failed' });\r\n        }\r\n    });\r\n}\r\n", "import { FastifyInstance } from 'fastify';\r\nimport { authRoutes } from './auth';\r\nimport { authOtpRoutes } from './auth_otp';\r\nimport { workspaceRoutes } from './workspaces';\r\nimport { repositoryRoutes } from './repositories';\r\nimport { jobRoutes } from './jobs';\r\nimport { orgRoutes } from './organizations';\r\nimport { communityRoutes } from './community';\r\nimport { profileRoutes } from './profile';\r\nimport { forgeRoutes } from './forge';\r\nimport { notificationRoutes } from './notifications';\r\nimport { adminRoutes } from './admin';\r\nimport { searchRoutes } from './search'; // Global Search\r\nimport { ChatService } from '../services/chat';\r\n\r\n\r\n\r\nexport async function routes(fastify: FastifyInstance) {\r\n    fastify.get('/', async () => {\r\n        return { status: 'ok', message: 'TrackCodex Backend API v2 (Prisma)' };\r\n    });\r\n\r\n    // Chat WebSocket\r\n    fastify.get('/chat', { websocket: true }, (connection, req) => {\r\n        ChatService.handleConnection(connection, req);\r\n    });\r\n\r\n    await fastify.register(authRoutes);\r\n    await fastify.register(authOtpRoutes);\r\n    await fastify.register(notificationRoutes); // NEW\r\n    await fastify.register(workspaceRoutes);\r\n    await fastify.register(repositoryRoutes);\r\n    await fastify.register(jobRoutes);\r\n    await fastify.register(orgRoutes);\r\n    await fastify.register(communityRoutes);\r\n    await fastify.register(profileRoutes);\r\n    await fastify.register(forgeRoutes);\r\n    await fastify.register(adminRoutes);\r\n    await fastify.register(searchRoutes);\r\n}\r\n", "/**\r\n * CSRF Protection Middleware\r\n * Protects against Cross-Site Request Forgery attacks\r\n */\r\n\r\nimport { FastifyRequest, FastifyReply } from \"fastify\";\r\nimport { validateCsrfToken } from \"../services/session\";\r\n\r\n/**\r\n * CSRF middleware - validates CSRF tokens on state-changing requests\r\n */\r\nexport async function csrfProtection(\r\n  request: FastifyRequest,\r\n  reply: FastifyReply,\r\n) {\r\n  // Skip if path is exempt\r\n  if (isCsrfExempt(request.url)) {\r\n    return;\r\n  }\r\n\r\n  // Only check CSRF on state-changing methods\r\n  if (![\"POST\", \"PUT\", \"DELETE\", \"PATCH\"].includes(request.method)) {\r\n    return;\r\n  }\r\n\r\n  // Debug logging for Session/CSRF investigation\r\n  console.log(\"[CSRF Debug] Method:\", request.method, \"Path:\", request.url);\r\n  console.log(\"[CSRF Debug] Origin:\", request.headers.origin);\r\n  console.log(\"[CSRF Debug] Cookies:\", JSON.stringify(request.cookies));\r\n  console.log(\"[CSRF Debug] Headers:\", Object.keys(request.headers));\r\n\r\n  // Get session ID from cookie\r\n  const sessionId = request.cookies?.session_id;\r\n  if (!sessionId) {\r\n    console.warn(\"[CSRF Failure] No session_id in cookie\");\r\n    return reply.code(401).send({\r\n      error: \"Unauthorized\",\r\n      message: \"No session found - Cookie missing\",\r\n    });\r\n  }\r\n\r\n  // Get CSRF token from header\r\n  const csrfToken = request.headers[\"x-csrf-token\"] as string;\r\n  if (!csrfToken) {\r\n    return reply.code(403).send({\r\n      error: \"Forbidden\",\r\n      message: \"CSRF token required\",\r\n    });\r\n  }\r\n\r\n  // Validate token\r\n  const isValid = await validateCsrfToken(sessionId, csrfToken);\r\n  if (!isValid) {\r\n    return reply.code(403).send({\r\n      error: \"Forbidden\",\r\n      message: \"Invalid CSRF token\",\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Generate and return CSRF token in response\r\n */\r\nexport function attachCsrfToken(request: FastifyRequest, reply: FastifyReply) {\r\n  const csrfToken = (request as any).csrfToken;\r\n  if (csrfToken) {\r\n    reply.header(\"X-CSRF-Token\", csrfToken);\r\n  }\r\n}\r\n\r\n/**\r\n * CSRF exempt routes (OAuth callbacks, webhooks, etc.)\r\n */\r\nexport const csrfExemptPaths = [\r\n  \"/api/v1/auth/google\",\r\n  \"/api/v1/auth/github\",\r\n  \"/api/v1/auth/login\",\r\n  \"/api/v1/auth/register\",\r\n  \"/api/v1/webhooks/\",\r\n];\r\n\r\n/**\r\n * Check if path is exempt from CSRF\r\n */\r\nexport function isCsrfExempt(path: string): boolean {\r\n  return csrfExemptPaths.some((exemptPath) => path.startsWith(exemptPath));\r\n}\r\n"],
  "mappings": "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",
  "names": ["process", "err", "port", "docker", "process", "PrismaClient", "crypto", "PrismaClient", "prisma", "PrismaClient", "prisma", "prisma", "PrismaClient", "crypto", "PrismaClient", "prisma", "PrismaClient", "prisma", "WorkspaceManager", "PrismaClient", "prisma", "PrismaClient", "prisma", "PrismaClient", "PrismaClient", "prisma", "prisma", "PrismaClient", "prisma", "prisma", "PrismaClient", "PrismaClient", "prisma", "PrismaClient", "prisma", "process", "fs", "path", "require", "Docker", "docker", "path", "fs", "PrismaClient", "PrismaClient", "prisma", "prisma", "PrismaClient", "PrismaClient", "prisma", "PrismaClient", "PrismaClient", "prisma", "PrismaClient", "PrismaClient", "path", "prisma", "PrismaClient", "process"]
}
